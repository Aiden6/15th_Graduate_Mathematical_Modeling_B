![资源 2](media/image1.png){width="1.6in" height="1.0243055555555556in"}
![E:\\专项工作\\中国研究生数学建模大赛\\第十四届研究生数学建模竞赛\\新会徽.jpg](media/image2.jpeg){width="1.2638888888888888in"
height="1.2243055555555555in"}
![华为](media/image3.jpeg){width="1.1840277777777777in"
height="1.1840277777777777in"}

![微信图片\_20171016152322](media/image4.png){width="1.1041666666666667in"
height="1.1118055555555555in"}
![微信图片\_20180821152024\_副本](media/image5.jpeg){width="1.45625in"
height="1.2402777777777778in"}

**"华为杯"第十五届中国研究生**

**数学建模竞赛**

  -------------- --------------
  **学 校**      重庆邮电大学
  **参赛队号**   18106170112
  **队员姓名**   **1.刘芷倩**
                 **2.刘晓东**
                 **3.王斐**
  -------------- --------------

**\
**

**"华为杯"第十五届中国研究生**

**数学建模竞赛**

题 目 **光传送网建模与价值评估**

![](media/image6.png){width="3.263888888888889in"
height="4.9305555555555554e-2in"}

**摘 要**

在通信行业迅速发展的时代，光传送网为网络中的底层。本文首先对光传输链路模型进行了建模，研究了不同调制方案的BER与SNR关系曲线；其次对因网络的连接给两地带来的价值进行评估，并建立了相应模型，通过算法使网络价值最大；最后通过算法改进调制方案，提高了通信系统的容忍噪声能力。本文所做的光传送网络建模与价值评估，对现实中核心网建设提供了一定参考依据，并能进一步加快中国5G的通信建设。

针对问题一，在子问题-1中，对于三种调制格式（QPSK、8QAM、16QAM）编码方案的纠前误码率（BER）与信噪比（SNR）的关系曲线，通过建立基本**数字通信传输模型**，了解了二进制序列传输过程中误码率的产生原理。同时，利用星座点噪声的公式定义，确定工程意义上的信噪比公式。采用MATLAB实现数字传输模型的建立，最终得到三种调制格式方案的BER-SNR关系曲线图，并得出当BER=0.02时，三种调制格式（QPSK、8QAM、16QAM）SNR的容限点分别为6.35、10.9和13.29。在子问题-2中，在前一问题中得出的数字传输模型基础上，**引入放大器噪声和光纤噪声**。通过分析单跨信号衰减的幅度，由给定的噪声公式得出叠加的噪声，进而得出噪声与传输距离的关系曲线图。由他们的关系可得，单跨为80km时，QPSK调制格式最远传输距离为9600km；8QAM调制格式最远传输距离为4800km；16QAM调制格式最远传输距离为4000km。单跨为100km时，QPSK调制格式最远传输距离为10000km；8QAM调制格式最远传输距离为5000km；16QAM调制格式最远传输距离为4000km。

针对问题二，子问题-1和子问题-2均属于单目标优化问题，子问题-3属于多目标优化问题，三个子问题均采用**遗传算法**求解。**在子问题-1中**，无需考虑中间节点的问题，在12个城市点均连接在网络上的前提下，给定网络中的连接数量，求解当网络价值最大时，城市点的规划。采用**Dijkstra算法**的遍历思想，当网络连接线遍历每个城市点时，进行下一个步骤，否则采用**惩罚手段**使此时的适应度函数值为0。最终得出：n=16最大网络价值为4068.4214mTb/s，约迭代50次左右网络价值趋于最优；n=33最大网络价值为6854.7631mTb/s，约迭代150次左右网络价值趋于最优。**在子问题-2中**，需要**考虑中间节点和设备容量**问题，在不超过每个城市设备点最大容量的前提下，求解最大价值网络。同样采用遗传算法，得出：n=16最大网络价值为2731.5505mTb/s，约迭代250次左右时网络价值趋于最优；n=33最大网络价值为7318.3339mTb/s，约迭代40次左右时的网络价值趋于最优。当城市点由市扩大到省时，关键是人口数量发生了改变，此时得出的结果为：n=16最大网络价值为2731.5505mTb/s，约迭代250次左右时网络价值趋于最优；n=33最大网络价值为7318.3339mTb/s，约迭代40次左右时的网络价值趋于最优。**在子问题-3中**，若要满足连接发达城市以获得更高的收入，则用**GDP衡量每条路径的权重**，从而使网络价值随权重变化而变化；若要保障发展相对滞后的地区的通信，则使网络规划路线中**网孔的个数尽可能多**。此时结果为：n=16最大网络价值为2359.2138mTb/s，约迭代450次左右时网络价值趋于最优；n=33最大网络价值为：4351.0578mTb/s，约迭代240次左右时，网络价值波动虽然没有稳定在一定的数值，但是波动情况较小，即将趋于稳定。

针对问题三，对于保持调制格式的信息熵为3bit，我们分析信息熵只与星座点的数量和每个点的概率有关。我们通过将星座点的数量减少为8个，且令每个点的概率相同，实现了这一目标。对于降低SNR容限点的目标，我们考虑改变星座点的位置，采用遗传算法，根据通信原理的相关知识，设置适应度函数选出使相邻星座点的**欧式距离较大**的星座图，逐步迭代求得SNR容限点小于8QAM的星座图。问题三的最优星座图呈现心形，如正文中所示。

**关键字：**遗传算法、适应度函数、Dijkstra算法、光传送链路模型

目 录 {#目-录 .TOC}
=====

[[一、问题重述]{.underline} 4](#一问题重述)

> [[1.1 问题背景]{.underline} 4](#问题背景)
>
> [[1.2 需解决的问题]{.underline} 4](#需解决的问题)

[[二、模型假设]{.underline} 9](#二模型假设)

[[三、符号说明]{.underline} 10](#三符号说明)

[[四、问题一：光传送链路建模]{.underline} 11](#四问题一光传送链路建模)

> [[4.1 子问题-1：纠前信噪比与误码率的计算]{.underline}
> 11](#子问题-1纠前信噪比与误码率的计算)
>
> [[4.1.1 问题分析]{.underline} 11](#问题分析)
>
> [[4.1.2 问题求解]{.underline} 11](#问题求解)
>
> [[4.2 子问题-2：光链路性能计算]{.underline}
> 13](#子问题-2光链路性能计算)
>
> [[4.2.1 问题分析]{.underline} 13](#问题分析-1)
>
> [[4.2.2 问题求解]{.underline} 13](#问题求解-1)
>
> [[4.2.3 结果分析]{.underline} 15](#结果分析)

[[五、问题二：光传送网规划]{.underline} 16](#五问题二光传送网规划)

> [[5.1 子问题-1：单目标网络规划及其价值]{.underline}
> 16](#子问题-1单目标网络规划及其价值)
>
> [[5.1.1 问题分析]{.underline} 16](#问题分析-2)
>
> [[5.1.2 数据处理]{.underline} 16](#数据处理)
>
> [[5.1.3 模型建立]{.underline} 17](#模型建立)
>
> [[5.1.4 模型求解]{.underline} 20](#模型求解)
>
> [[5.2 子问题-2：多约束单目标网络规划及其价值]{.underline}
> 23](#子问题-2多约束单目标网络规划及其价值)
>
> [[5.2.1 问题分析]{.underline} 23](#问题分析-3)
>
> [[5.2.2 数据处理]{.underline} 23](#数据处理-1)
>
> [[5.2.3 模型建立]{.underline} 24](#模型建立-1)
>
> [[5.2.4 模型求解]{.underline} 25](#模型求解-1)
>
> [[5.3 子问题-3：多约束多目标网络规划及其价值]{.underline}
> 30](#子问题-3多约束多目标网络规划及其价值)
>
> [[5.3.1 问题分析]{.underline} 30](#问题分析-4)
>
> [[5.3.2 模型建立]{.underline} 30](#模型建立-2)
>
> [[5.3.3 模型求解]{.underline} 30](#模型求解-2)

[[六、问题三：改进调制格式]{.underline} 34](#六问题三改进调制格式)

> [[6.1 问题分析]{.underline} 34](#问题分析-5)
>
> [[6.2 模型建立]{.underline} 34](#模型建立-3)
>
> [[6.3 模型求解]{.underline} 34](#模型求解-3)

[[参考文献]{.underline} 37](#参考文献)

[[附录]{.underline} 38](#附录)

一、问题重述
============

1.1 **问题背景**
----------------

光纤通信通信系统是一种以光为传输载波，以光纤作为传输媒介，通过一系列电光、光电变换来传输信息的通信系统。光纤以其大容量、远距离传送等特性，以及光在传输过程中速率高、介质可靠性高、业务透明等诸多优点，光纤通信自诞生以来已经成为信息时代中主要通信技术之一。

光纤通信从诞生至今，50多年里基于数字光纤通信技术的光传送网构建起了全球通信的骨架。从城市内一家一户间的传输，到城市与城市之间的传输，甚至于跨越大洋的传输和跨越国界的传输都有光纤通信的踪迹。光传送网为人类提供了大容量、高可靠性和低能耗的信息传输管道。光纤通信技术的崛起，光传送网的不断扩大，使得相关研究者们逐渐将注意力集中到了光传送网的规划和建设。

光传送网是整个光通信的承载网络，所有基于光通信的各类业务网络都依靠光传送网提供数据传送服务，因此传送网网络性能直接关系到上层各类业务网络的通信质量。光传送网的合理规划和建设将从根本上影响传送网的传送性能，改善网络质量。同时，随着人类对通信容量、通信质量追求的不断扩大，光传送网的规划逐渐成为光通信领域研究的重要方向之一。各大运营商、设备制造商、政府相关部门及研究机构都将光传送网的规划与建纳入改善网络质量的重要考虑对象。

光纤通信相比于其它通信方式有自己独有的特性，因此在对光传送网进行规划时，不能照搬其它通信传送网方式。光通信最大的特点之一是，光在传输过程中会逐渐衰减。在长距离传输中，为克服光的这一特性，经常需要在一段距离点将光信号放大后再传输。也因为光的这一特性，使得在相同技术条件下信号传输容量会随着传输距离增加而减小。对于光传送网的规划者而言，需要充分考虑到光通信的各种特性，从而提升网络质量。

就目前的研究来看，为使传送网的价值最大化，光传送网规划者往往需要考虑传输容量、传输距离、网络拓扑等多种因素的影响。优化光传送网、规划光传送线路已然是光纤通信领域研究热点之一。

1.2 需解决的问题
----------------

本课题中，为研究光传送网的规划，需从底层物理出发建立光传送链路的模型；基于网络价值与光传送链路模型，制定光传送网的规划；改进调制格式以改善传送网性能，延长链路总长度。故需要解决以下三方面的内容：

**（1）问题-1：光传送链路建模**

现代数字传输系统就是对0101二进制序列进行编码并传输的系统，一个二进制的0或1称为1个比特。众所周知，无论是语音消息、视频消息还是各种其它类型的消息，都可以转化为一串像"0101..."这种数字型的二进制比特序列。传统的通信方式中，该序列在发送端由调制器编码调制成某个"载体信号"，通过信道传送到达目的地，接收端通过解调器解调载体信号为发送端的二进制序列。图1.1是上述过程的简化模型。

光纤通信同样也沿用该模型，传输信道就是光纤，信息的载体是光波。在该模型中，信道中出现噪声是不可避免的，一旦有噪声干扰信号传输，就可能导致接受端最终接受的二进制序列与发送端发送的二进制序列不一致。显然这是任何通信中都不愿看到的，因此通信系统抗干扰能力也成为重要的衡量指标之一。

图1.1 简化后的数字传输模型

在信号传输中，二进制序列通常不是一个个传输，而是以块为单位传输。假定二进制序列将K个比特作为一个"符号"传输，那么该符号中就有个不同状态。光纤通信中，通常采用光波的复振幅来承载传输信号。因此，复平面上不同的点正好可以描述二进制序列"符号"的不同状态，复平面上的点称为"星座点"，这些星座点构成的图为"星座图"。图1.2(a)是发送端的四个点构成的星座图，这些信号经过QPSK（Quadrature
Phase Shift
Keying）调制，信道叠加噪声和接收机处理后，接收端的星座图不再是理想的四个点，而是相对扩散的点。之所以会这样，是因为当接收机接收到一个符号时，由于噪声的影响，会将这个符号判定为离这个符号最近的星座点。显然，存在噪声且对符号影响足够大，就会导致接收到的符号可能被判错到其它地方，这样就产生了误码。图1.2(b)是接受端接受到发送端的星座图，其中蓝色的点就是一个误码。BER是衡量通信系统性能的最根本指标，采用纠错编码，只要纠前BER小于BER容限点，纠错编码后就能实现纠后误码率为零的传输。

图1.2 星座图与噪声导致误码的示意图

**图1.3中理想星座点用**$s_{k}$**表示，接收到的符号用**$r_{k}$**表示，则噪声为：**

${\mathbf{\ }n}_{\mathbf{k}}\mathbf{=}\mathbf{r}_{\mathbf{k}}\mathbf{-}\mathbf{s}_{\mathbf{k}}$
(1.1)

噪声通常服从均值为0的正态分布。噪声的方差等于噪声的平均功率，定义为：

$P_{n}\mathbf{=}\frac{\mathbf{1}}{\mathbf{N}}\sum_{\mathbf{k = 1}}^{\mathbf{N}}\left| \mathbf{n}_{\mathbf{k}} \right|^{\mathbf{2}}$
(1.2)

其中N为总共传输的符号数。信号平均功率定义为发送符号绝对值平方的均值：

$P_{\mathbf{s}}\mathbf{=}\frac{\mathbf{1}}{\mathbf{N}}\sum_{\mathbf{k = 1}}^{\mathbf{N}}\left| \mathbf{s}_{\mathbf{k}} \right|^{\mathbf{2}}$
(1.3)

定义信号和噪声功率的比值为信噪比（Signal-to-Noise Ratio, SNR）：

$SNR = P_{s}/P_{n}$ (1.4)

工程上通常用dB作为SNR的单位，定义为：

$\text{SNR}\left( \text{dB} \right) = 10log10(P_{s}/P_{n})\ $ (1.5)

增大十倍为加10dB，减小0.5倍为减去3dB。本题中功率单位统一为毫瓦（mW），星座图实部和虚部单位为$\sqrt{\text{mW}}$。

图1.3 信号和噪声的相关定义示意图

图1.4为基本的光传输链路模型，在远距离的信号传输中，光传输链路由多个相同的跨段级联形成，其中跨段为一段距离的光纤和一个放大器。信号通过光纤传输时，每传输15km，其功率就会衰减一半。因此，信号在光纤上每传输一段距离，就需要利用放大器对信号进行光功率补偿。同时，由于光纤传输过程中会不可避免的引入噪声，信号和噪声经过放大器同时被放大，就会使放大器本身也产生一个自发辐射噪声，其公式为：

$P_{n} = 2\pi hfB(\text{NF} + 1/\text{Gain})$ （1.6）

**其中是**$h$**是普朗克常数（**$6.62606896 \times 10^{- 34}\ J \bullet S$**），**$f$**是光波频率（可定为193.1THz），B为带宽（设为50GHz），NF为噪声指数（可设为4），Gain为补偿光纤衰减所对应的功率增益。**

图1.4 基本的光传输链路模型

另一方面，由于光纤是一种传输介质，本身传输过程中就会产生损耗，在这里表现的方式就是光纤的非线性效应，被等效为上文传输过程中的噪声。**其等效噪声功率与光纤功率近似呈平方关系，光纤功率为1mW时的非线性噪声约等于单个放大器噪声的2/3。**

**子问题-1）纠前误码率与信噪比计算**

**星座图的编码分布模式也称为调制格式，对于给定的调制格式，BER和SNR呈一一对应的关系，纠前BER门限对应的SNR记做"SNR容限点"。**给出图1.5中所示的三种调制格式及编码方式（相邻星座点距离相等），每个符号等概率出现，分别称为QPSK，8QAM
(Quadrature Amplitude Modulation,
QAM)，16QAM。请给出BER与SNR的关系曲线，BER=0.02时SNR容限点分别为多少？

图1.5 三种调制格式的编码方案

**子问题-2）光链路性能计算**

**当单跨传输距离为80km和100km两种情况，以纠前误码率0.02为门限，图5给出的传输格式最远的传输距离（每跨距离×跨段数量）是多少？**

**（2）问题-2 光传送网规划**

**如表1所示，是在更深层次优化升级后，三种不同传输格式的传输距离。而现代通信网的建立，就是为了使更多的人能够通过网络更好地连接在一起，故我们定义如下方式的网络的价值：**

1.  **每条直接连接两个城市/区域的链路当做1个连接，每个连接的价值定义为传输的容量与连接区域人口数的乘积（取两区域人口数乘积的0.5次方）**

2.  **网络的价值则是所有连接价值的加权和**

$网络价值 = \sum_{}^{}{权重*容量*人口}$ **(1.6)**

**表1 不同传输格式的传输距离**

  **单波传输容量**   **最大传输距离**   **总容量**
  ------------------ ------------------ -------------
  **100 Gb/s**       **3000 km**        **8 Tb/s**
  **200 Gb/s**       **1200 km**        **16 Tb/s**
  **400 Gb/s**       **600 km**         **32 Tb/s**

**如图1.6所示为北京、上海、南京的相对位置示意图，以此为例，若三个城市之间均互相连接，根据两城市之间的距离得出传输容量。假设每条连接链路的权重为1，通过人口算出网络价值（Network
Value, NV）为：**

$NV = \sqrt{21 \times 24}m \times 16Tb/s + \sqrt{21 \times 8}m \times 16Tb/s + \sqrt{24 \times 8} \times 32Tb/s \approx 1010mTb/s$
**(1.7)**

**其中m代表百万人(million)，**$Tb/s = 10^{12}bit/s$**,
该网络的连接数为3。**

**图1.6 三个节点网络示意图**

**实际情况往往会略有差异，诸如资源等影响因素，城市网络中并不是所有网络节点都能直接连接。图1.6(b)即表示不能直接连接的两个节点需要辅助节点建立连接。北京和南京为不能直接的两个节点，需要通过上海建立连接，此时该网络的连接数为2。当北京上海之间的传输仅保留一半容量(100Gb/s)，而另一半容量用于南京到北京的信号传输(100Gb/s)，相应地南京与上海之间的直接传输容量也会降低至300Gb/s，此时网络的价值为：**

$NV = \sqrt{21 \times 24}m \times 8Tb/s + \sqrt{21 \times 8}m \times 8Tb/s + \sqrt{24 \times 8} \times 24Tb/s \approx 616mTb/s$
(1.8)

**根据需要两个节点之间也可以有多个连接，考虑网络价值和需求为图1.7中的我国城市群制定光传送网规划，图中共有12个区域(其中北京/天津，深圳/广州均按1个区域对待)**

图1.7 需要考虑的城市群

**子问题-1:**如果连接数从16增加到33条时，不考虑中间节点，给出你们的两个网络规划及其价值。网络价值最多是多少？

**子问题-2：**存在中间节点，且两个节点之间可以有多个连接的情况下，重新解决子问题-1并给出所有中间节点传输容量的分配，假定每条链路容量可任意分配，只要总容量不超过表1的规定。如果由市扩大为省（区）影响如何？（人口请从网上查找）

**子问题-3:光传送**网络价值有多个侧面，例如从运营商的角度，连接经济发达的地区会带来更多的收入，从政府的角度保障发展相对滞后地区的通信是均衡发展的要求等。你队认为制定**光传送**网络规划的目标函数应该是什么？前面制定的规划有无变化？

**问题-3 改善星座图**

**由第一问可知，纠前BER不变时，降低SNR容限点可以提高系统容忍噪声的能力，从而延长链路的总长度。请尝试任意改变16QAM方案中星座点的位置、数量或每个点的概率，探索产生比图5中8QAM（相邻各星座点之间距离相等）具有更低SNR容限点的调制方案？调制格式的信息熵需保持为3bit。**

**信息熵定义为：**

$\Omega = - \sum_{1}^{N}{p_{k}\log_{2}{(p}_{k})\ }$ **(1.9)**

**其中**$p_{k}$**为每个符号状态出现的概率，N为状态数。图1.5所示的等概率情况下，QPSK、8QAM和16QAM的信息熵分别为2bit,
3bit和4bit。 **

二、模型假设
============

为了方便建模，作出如下一些简化假设：

1、假设传播过程中，只存在光纤的非线性效应等效噪声和放大器的自发辐射噪声，忽略其他损耗的影响；

2、在光传输链路的每一跨中，放大器对光功率的补偿，假设能将其补偿到单位"1"；

3、假设问题一中发送10000个符号对模型进行仿真；

4、假设在问题二中前两小问不考虑连接线路权重的影响，令其为1；

5、假设在求解不同规划的网络价值时，前提保证每个城市点都在网络中；

6、在问题二的子问题-3中，假设两城市点的连接线的GDP值为两城市点GDP总数乘积的0.5次方。

三、符号说明
============

表2 符号说明

  符号                                                   意义
  ------------------------------------------------------ ---------------------------------------
  $$\mathbf{\text{NV}}_{\mathbf{\text{ij}}}$$            i、j两地连接线的网络价值
  $$\mathbf{\text{Cap}}_{\mathbf{\text{ij}}}$$           i、j两地连接线的容量
  NF                                                     噪声指数
  B                                                      带宽
  $$\mathbf{n}$$                                         城市点的个数
  N                                                      城市点两两相连的总连接数
  $$\mathbf{\text{Num}}_{\mathbf{i}}$$                   i地的人口数量
  $$\mathbf{\text{NV}}_{\mathbf{\text{Total}}}$$         整个网络的价值
  $$\mathbf{W}_{\mathbf{\text{ij}}}$$                    i、j两地连接线的权重
  $$\mathbf{P}\left( \mathbf{x}_{\mathbf{i}} \right)$$   个体$x_{i}$被遗传到下一代种群中的概率
  $$\mathbf{q}_{\mathbf{i}}$$                            个体$x_{i}$的累积概率
  $$\mathbf{\text{Eco}}_{\mathbf{i}}$$                   i地的经济发展权重

四、问题一：光传送链路建模
==========================

4.1 子问题-1：纠前信噪比与误码率的计算
--------------------------------------

### 4.1.1 问题分析

在光传送过程，信号以光纤为载体，从发送端传输到接收端，在此过程中计入噪声对信号影响所产生的损耗，再通过放大器对损耗的光功率进行补偿。但在信号传输过程中，由于噪声的影响，使信号不再是以前的理想状态而出现偏差，因此本题探讨误码率（BER）与信噪比（SNR）在三种不同的调制格式下的关系曲线。在求解SNR容限点时，结合上一步得出的关系曲线图，当BER=0.02时，得到各个调制格式下的SNR容限点即为所求。

### 4.1.2 问题求解

在光纤通信^\[1\]^中，其链路传输基本模型如图4.1所示。二进制序列先通过相位转化，将"符号"表现在星座图上，便于观察，初始时刻是理想的星座图，经过噪声的影响后，重新将这个序列逆映射在星座图上。通过比较前后两个星座图中星座点的位置，得出需要计算的误码率。

图4.1 传输链路模型

在第一小问中，假设信噪比（SNR）在1-25（dB）中变化。在MATLAB中生成三种调制格式的理想星座图，每种序列经过调制器变换后，再计入链路传输中噪声的影响（加入信噪比为25的噪声），得到如图4.2所示的可能存在误码率的星座图。

![](media/image16.png){width="3.2246041119860016in" height="1.7in"}

(a) QPSK星座图

![](media/image17.png){width="3.271244531933508in"
height="1.6758431758530183in"}

(b) 8QAM星座图

![](media/image18.png){width="3.2599048556430446in"
height="1.742716535433071in"}

(c) 16QAM星座图

> 图4.2 三种调制格式的星座图

在讨论QPSK、8QAM、16QAM的误码率（BER）与信噪比(SNR)之间的关系时^\[2\]^，首要任务是如何判断计入噪声影响的符号是否属于误码。根据题意，在QPSK中，当某一象限的符号出现在其它象限，就属于误码情况；在8QAM中，当经过噪声影响后的符号出现在原始信号一定范围之外的范围，属于误码情况；16QAM与8QAM同理。

在接收设备受到某个信号后，解码设备对其进行解码，由于通信链路上有噪声干扰，解码设备对接收到信号的解码需要一定的容错，我队对接收到信号的星座图解码算法如下：

1)  计算接收到的符号与编码方案中星座图中每个星座点的距离；

2)  找到所有距离中，最小的一个距离；

3)  查找该最小距离是与哪个星座点的距离；

4)  确定该接收到符号即为该星座点编码；

5)  按该星座点对该符号进行解码。

另一方面，根据题中所给的噪声服从均值为0
的正态分布，此时加入的噪声属于高斯白噪声。根据题中给定的调制解调方式，并在传输链路中加入高斯白噪声，结合上一步得出的星座图，通过MATLAB编程可得出三种调制方式BER与SNR的关系曲线，如图4.3所示，其具体代码见附录。

由图4.3可得，在BER=0.02这一条件下，当调制格式为QPSK时，SNR容限点为6.35；当调制格式为8QAM时，SNR容限点为10.9；当调制格式为16QAM时，SNR容限点为13.29。

![](media/image19.png){width="4.739335083114611in"
height="2.483786089238845in"}

图4.3 三种调制格式BER与SNR的关系曲线

4.2 子问题-2：光链路性能计算
----------------------------

### 4.2.1 问题分析

本小题要求考虑单跨传输距离为80km和100km两种情况下，以纠前误码率（BER）0.02为门限，计算给定的三种调制格式^\[3\]^（QPSK、8QAM、16QAM）最远的传输距离。由于放大器噪声和非线性噪声会逐跨叠加，导致信噪比（SNR）降低，故这一问的本质是求解：经过一段距离的光纤传输之后，达到纠前BER为0.02为门限时对应的SNR容限点时的传输距离，此距离就是最远的传输距离。

### 4.2.2 问题求解

光传输链路是由多个相同跨段级联而成，几十千米的光纤与一个放大器构成1个跨段。为了直观地了解光传输过程，首先做出基本的光纤传输链路模型，如图4.5所示。可以看到，在光纤传输过程中，噪声来自光纤本身的非线性效应引入的等效噪声和放大器的自发辐射噪声。其中，前者在每跨开头叠加，后者在每跨末位叠加。每跨中间信噪比保持不变，每跨叠加的噪声间相互独立。

图4.4 光纤传输链路模型

光纤传输模型^\[4\]^中，放大器噪声的公式为：

(4.1)

其中是$\mathbf{h}$是普朗克常数（$6.62606896 \times 10^{- 34}\ J \bullet S$），$\mathbf{f}$是光波频率（可定为193.1THz），B为带宽（设为50GHz），NF为噪声指数（可设为4），Gain为补偿光纤衰减所对应的功率增益。另一方面，光纤本身非线性噪声功率与光纤功率近似呈平方关系^\[5\]^，光纤功率为1mW时的非线性噪声约等于单个放大器噪声的2/3。

假设噪声功率与光纤功率的关系式为，当时，$y = \frac{2}{3}*P_{n} = k*1^{2}$，则。故光纤传输过程中本身的非线性效应等效噪声：

$P_{非} = \frac{2}{3}P_{n}$ (4.2)

本文将问题分为两个部分进行分析，具体求解过程如下：

（1）当单跨传输距离为80km时各调制格式的最大传输距离为：

步骤1：在第一小问的基础上，将传输链路模型中的高斯白噪声替换为光纤的非线性等效噪声和放大器噪声。光纤的非线性等效噪声在每跨开头叠加，放大器噪声在每跨末尾叠加；

步骤2：由于每隔15km，光功率衰减一半；故当单跨传输距离为80km时，光功率衰减为原来的倍；

步骤3：在MATLAB代码中设置循环语句，重复光功率衰减与补偿的过程。在此过程中，叠加放大器的噪声和光纤噪声；

步骤4：当SNR数值达到BER=0.02门限所对应的SNR容限点时，代码循环结束。此时得到跨段数量与BER的关系曲线图，如图4.5所示。

![](media/image28.png){width="5.552083333333333in" height="3.4in"}

图4.5 跨段数量与BER的关系曲线图（单跨为80km）

（2）当单跨传输距离为100km时各调制格式的最大传输距离

此问题与1相比，仅仅改变了距离因素，所以在（1）的解题步骤基础上，改变步骤3中光的衰减率，由倍变为倍。因此放大器的噪声$P_{n}$和光纤噪声$\frac{2}{3}P_{n}$也随之增加。得到跨段数量与BER的关系曲线图，如图4.6所示。

![](media/image30.png){width="5.583333333333333in"
height="3.1279932195975504in"}

图4.6 跨段数量与BER的关系曲线图（单跨为100km）

### 4.2.3 结果分析

由图4.5可知，单跨为80km时，QPSK调制格式最远传输距离为9600km；8QAM调制格式最远传输距离为；16QAM调制格式最远传输距离为。

由图4.6可知，单跨为100km时，QPSK调制格式最远传输距离为10000km；8QAM调制格式最远传输距离为；16QAM调制格式最远传输距离为。

五、问题二：光传送网规划
========================

5.1 子问题-1：单目标网络规划及其价值
------------------------------------

### 5.1.1 问题分析

子问题-1是在城市连接点分别为16和33，且不考虑城市中间节点的情况下，求解网络价值最多时，城市点的网络规划，并求此时网络的最大价值。在本小题中，根据题中式1.6可知，网络价值与每条连接的权重有关，此问的求解与连接的权重无很大关系，因此在本题求解中，假设每条连接的权重为1。综上所述，本小问**关键问题是对每条线路容量的计算**。

根据题意及参考文献，本题为**典型的单目标优化问题**，因此我队采用**遗传算法**^\[6\]^来规划网络中城市的连接。

### 5.1.2 数据处理

在网上对题中给定的城市点进行搜索，得出各个城市点的经纬度及人口如表3所示。

表3 城市经纬度及人口数量

  城市             经度（${^\circ}$）   纬度（${^\circ}$）   人口（百万）
  ---------------- -------------------- -------------------- --------------
  哈尔滨           126.53               45.80                9.9526
  北京&天津        116.46               39.92                34.8245
  郑州             113.66               34.75                9.03
  上海             121.47               31.23                23.8043
  武汉             114.3                30.60                10.12
  广州&深圳        113.27               23.13                23.3863
  西安             108.93               34.27                8.8321
  乌鲁木齐         87.62                43.82                3.80
  拉萨             91.11                29.97                0.9025
  成都             104.7                30.67                16.0447
  昆明             102.72               25.05                7.2131
  重庆（主城区）   106.55               29.57                8.6506

来源：经纬度在线查询、国家统计局

利用数据画出城市的二维坐标图，如图5.1所示：

![](media/image35.png){width="5.131211723534558in"
height="2.736111111111111in"}

图5.1 城市点位置图

### 5.1.3 模型建立

1.  **遗传算法**简介：

遗传算法（Genetic
Algorithm）是1975年Michigan大学的J.Holland教授提出的一种算法，这种算法是基于达尔文的生物进化论中"适者生存，优胜劣汰"和孟德尔遗传学的理论基础，模拟生物进化过程提出来的一种计算模型，并利用随机搜索来求取问题的最优解。在遗传算法中，将二进制或自然数等简单编码方式来比拟遗传学中的染色体，模拟其选择、交叉、变异等生物进化机制来解决复杂的优化问题，其程序流程图如图5.2所示。

图5.2 遗传算法流程图

以下为遗传算法中需要重点考虑的问题：

(1) 编码策略

生物中的遗传性状是由每个生物的遗传基因决定的，在使用遗传算法求解优化问题时，把优化问题中每一个可行解通过浮点编码或者二进制编码，将其转化为基因串，成为遗传问题中的一个个体。针对不同问题有不同的编码、解码方式，一般的数学优化问题通常将个体编码成二进制的形式。

(2) 初始种群

遗传算法中的初始种群是由若干个遗传个体组成，其中一个个体代表优化问题的可行解。遗传算法主要是对种群进行操作，因此需要根据问题的可行解，随机生成若干个个体，组成初始种群的数据。

(3) 适应度函数

遗传算法中的适应度函数通常是目标函数，它体现了遗传个体对环境的适应程度，适应程度高的个体就能继续在种群中生存，这充分体现了达尔文"优胜劣汰"的物种进化思想。

(4) 遗传算子

遗传算法的进化是基于遗传算子共同作用而实现的。遗传算子有选择（Selection）、交叉（Crossover）、变异（Mutation）三种，这三种遗传算子相互作用于初始种群中，使其产生下一代种群，推动种群的进化。

对于选择算子，是按照遗传个体的适应度值的大小有选择的将一些优秀个体直接放入下一代种群中，当然也可以忽略这一步骤直接进入交叉和变异这两个步骤。常用的选择算法有：轮盘赌选择法、随机联赛选择法和最佳个体保留选择法。

对于交叉算子，是将种群中两个随机的遗传个体按照一定的规则交换部分基因，从而形成新的两个个体，常用的交叉方法有：单点交叉、双点交叉、多点交叉和均匀交叉等。

对于变异算子，这一算子类似于生物遗传中的基因突变：给种群中某一个体的一个或者多个基因小概率的扰动，使其成为一个新的个体的过程。这种算子也可以保持种群的多样性，进而增强遗传算法的全局能力。

根据遗传算法的算法流程图以及算法中关键因子的确定可得遗传算法的伪代码实现如下：

  算法：遗传算法
  ---------------------------------------------------------
  输入：随机种群
  输出：适应度较好的个体
  1 Begin
  2 I=0;//进化种群代数
  3 Initialize P(I);//初始化种群
  4 Fitness P(I);// "适者生存"遗传选择
  5 While(not Terminate-condition) //不满足终止条件时循环
  6 {
  7 Fitness P(I);//"适者生存"遗传选择
  8 GA-Operation P(I);//遗传算字交叉or变异
  9 I++;//下次循环
  10 }
  11 End

2.  **模型建立**

问题二的第一小问属于单目标优化问题，给定城市点的位置以及城市之间的连接线的数量，来求解能够使网络价值最大时，该网络的城市点应该如何连接。对于单目标问题，可以采用蚁群算法、粒子群算法、模拟退火算法、遗传算法等，但是前三种算法对初始种群的依赖较大，若初始种群选择不恰当，就可能导致算法得出的结果不是较理想的。对于遗传算法，虽然可能陷入局部最优，但遗传算法是从群体出发进行搜索，最终收敛到个体，且个体之间可以多个同时比较，具有潜在的并行性和较高的全局性等优点。另一方面，要保证所有城市点均连接在所求网络中，可将此问题当做是一个小的**TSP问题**，采用Dijkstra算法，利用遍历的思想解决这一问题。

本题模型的具体框架如图5.3所示，以**遗传算法**作为模型的基本框架，在适应度函数中嵌入**Dijkstra算法**，其作用是：判断通过遗传算法得出网络规划路线是否满足遍历每个点，若是，则适应度函数保持不变；否则，采用**惩罚手段**使此时的适应度函数为0。用此手段处理后的网络规划不会迭代到下一代种群中，还可以保证每一个城市点连接在网络连线图中。

图5.3 算法框架图

在本题中，遗传算法模型^\[7\]^建立如下：

(1) 染色体编码

12个城市点两两相连，由公式5.1可得总连接数为66条。

$N = \frac{n \times (n - 1)}{2}$ (5.1)

其中，n表示城市点的个数，N表示n个城市两两相连的总连接数。

利用遗传算法解决光传输线路规划问题时，采用的编码方式是：

1)  对66条连接链路进行1-66的编号；

2)  将编好号的66个数随机地放入一个个体中的66个染色体空位中，形成一个种群中的个体，若假设初始种群中个体数量为50，则余下的49个个体采用同样的方法随机生成。

<!-- -->

(2) 初始种群

初始种群的产生依赖于随机函数，在该模型中一个个体是由66个线路基因组成，而这66基因是采用链路序号进行编码随机生成的。

(3) 适应度函数

本题中适应度函数就是目标函数，根据题中的定义，每个连接线价值为：

$\text{NV}_{\text{ij}} = \text{Cap}_{\text{ij}} \times \sqrt{\text{Num}_{i} \times \text{Num}_{j}}$
(5.2)

其中，$\text{NV}_{\text{ij}}$表示i、j两地连接线的网络价值（Network
Value），$\text{Cap}_{\text{ij}}$表示i、j两地连接线的容量，$\text{Num}_{i}$、$\text{Num}_{j}$分别表示i、j两地的人口数量。

整个网络的目标函数就是所有连接线价值的加权和：

$\text{MAX\ }\text{NV}_{\text{Total}} = \sum_{}^{}{W_{\text{ij}}*\text{NV}_{\text{ij}}}，(i,j = 1,2,\ldots,12)$
(5.3)

其中，$W_{\text{ij}}$表示i、j两地连接线的权重。

(4) 遗传算子

对于选择算子，在该问中，采用的是**轮盘赌选择法**，其基本思想为：种群中每个个体被选中的概率与其适应度大小成正比。其基本步骤为：

1)  计算M个种群中每个个体的适应度，在这里即是计算每个个体中被选中的16（或33）条连接线路的总的网络价值；

2)  计算出每个个体被遗传到下一代种群中的概率（利用第一步求得的适应度来求解）：

$P\left( x_{i} \right) = \frac{f(x_{i})}{\sum_{j = 1}^{N}{f(x_{i})}}$
(5.4)

3)  计算每个个体的累积概率

> $q_{i} = \sum_{j = 1}^{i}{P(x_{j})}$ (5.5)
>
> 其中，$q_{i}$表示个体$x_{i}$的累积概率。

4)  在区间\[0,1\]中产生随机数，若这个随机数刚好落在累加概率的某个体的区域内，则选择该区域的个体进入下一代；

5)  一直运行直到个体的数目达到初始种群的数目。

对于交叉和变异算子，在本题中是对产生的初始种群而言，随机选择两个个体，将个体中的基因进行交叉和变异操作，直到生成够一个新的种群为止。

Dijkstra算法步骤如下：

1)  选择城市i作为起点，再选择另外一个城市j作为终点，采用贪心法的算法策略，运用Dijkstra算法以起始点为中心向外层层扩散，直到扩散到终点；

2)  此次遍历得到一个最短路径，也即最大的网络价值（城市距离与链路价值呈负相关）；

3)  更换终点城市，判断得到的遍历路径是否在遗传算法得出的路径范围中，若是，跳出循环；否则继续；

4)  更换起点城市，重复步骤1-3。

### 5.1.4 模型求解

根据网络价值的模型，可以在MATLAB中实现对光传送网的规划。当城市点连接数n=16时，其规划具体路线如图5.3(a)所示，此时最大网络价值为：4068.4214mTb/s；而随着迭代次数的增加，城市网络价值的变化曲线如图5.3(b)所示，迭代次数在50次左右时，网络价值趋于最优。

![](media/image38.png){width="4.947891513560805in"
height="2.702694663167104in"}

(a) 网络线路规划图

![](media/image39.png){width="4.975984251968504in"
height="2.664722222222222in"}

(b) 迭代次数与网络价值的关系

图5.3 n=16时网络规划

同时，根据定义的变量得出各个城市点的邻接矩阵，如表4所示。结合表格的横纵数值对比分析，1代表城市点间有连接，0代表城市点间没有连接，可以分析出网络规划图的路线。(城市点编号：1-哈尔滨，2-北京&天津，3-郑州，4-上海，5-武汉，6-广州&深圳，7-西安，8-乌鲁木齐，9-拉萨，10-成都，11-昆明，12-重庆)

表4 n=16 各城市点的邻接矩阵

       1   2   3   4   5   6   7   8   9   10   11   12
  ---- --- --- --- --- --- --- --- --- --- ---- ---- ----
  1    0   1   0   0   0   0   0   0   0   0    0    0
  2    1   0   1   1   1   0   1   0   1   0    0    0
  3    0   1   0   1   1   0   1   0   0   0    0    0
  4    0   1   1   0   1   1   0   0   0   0    0    0
  5    0   1   1   1   0   0   0   1   0   0    0    0
  6    0   0   0   1   0   0   0   0   0   0    1    1
  7    0   1   1   0   0   0   0   0   0   0    0    1
  8    0   0   0   0   1   0   0   0   0   0    0    0
  9    0   1   0   0   0   0   0   0   0   0    0    0
  10   0   0   0   0   0   0   0   0   0   0    0    1
  11   0   0   0   0   0   1   0   0   0   0    0    0
  12   0   0   0   0   0   1   1   0   0   1    0    0

当城市点连接数n=33时，其规划具体路线如图5.4(a)所示，此时最大网络价值为：6854.7631mTb/s。而随着迭代次数的增加，城市网络价值的变化曲线如图5.3(b)所示，迭代次数在150次左右时的网络价值波动虽然没有稳定在一定的数值，但是波动情况较小，即将趋于稳定。

![](media/image40.png){width="4.966142825896763in"
height="2.695923009623797in"}

(a) 网络线路规划图

![](media/image41.png){width="5.0531222659667545in"
height="2.7078554243219597in"}

(b) 迭代次数与网络价值的关系

图5.4 n=33时网络规划

同理，根据定义的变量得出各个城市点的邻接矩阵，如表5所示。结合表格的横纵数值对比分析，可以分析出网络规划图的路线。

表5 n=33各城市点的邻接矩阵

       1   2   3   4   5   6   7   8   9   10   11   12
  ---- --- --- --- --- --- --- --- --- --- ---- ---- ----
  1    0   1   0   1   0   0   0   0   0   0    0    0
  2    1   0   1   1   1   1   1   0   0   1    1    0
  3    0   1   0   1   1   1   1   0   0   1    0    1
  4    1   1   1   0   1   1   0   0   0   1    0    0
  5    0   1   1   1   0   1   1   1   0   1    0    1
  6    0   1   1   1   1   0   0   0   1   1    1    1
  7    0   1   1   0   1   0   0   0   0   1    1    1
  8    0   0   0   0   1   0   0   0   0   0    0    0
  9    0   0   0   0   0   1   0   0   0   0    0    0
  10   0   1   1   1   1   1   1   0   0   0    1    1
  11   0   1   0   0   0   1   1   0   0   1    0    1
  12   0   0   1   0   1   1   1   0   0   1    1    0

5.2 子问题-2：多约束单目标网络规划及其价值
------------------------------------------

### 5.2.1 问题分析

子问题-2在1的基础上，要多考虑代表城市的两个节点之间，存在可以多个连接的情况，即节点1要到节点3，可以先经过节点2再转到节点3，而不是直接到达。在这种情况下，就需要考虑节点处设备容量的问题。因此，在这子问题-2中，需要解决的是在不超过每个城市设备点最大容量的前提下，使光传送网络的价值达到最大，并分别考虑连接数为16和33时网络的规划情况及容量分配。另一方面，当城市点由市扩大为省时，相较于市不同的是省包含的人口数量更大，从而会使网络中的价值更高。因此参考各个省的人口数量，用同样的方法可以得到新的网络规划图及容量分配。

### 5.2.2 数据处理

当城市点由市扩大到省（区）时，主要的变化就是区域内人口的变化，通过百度百科的统计，可以得到各个省（区）的人口数量如表6所示。

表6 各个省（区）人口的数量

  省（区）    人口（百万）   省（区）   人口（百万）
  ----------- -------------- ---------- --------------
  黑龙江      37.99          陕西       38.13
  北京&天津   37.35          新疆       23.98
  河南        95.32          西藏       3.31
  上海        24.20          四川       82.62
  湖北        58.85          云南       47.71
  广东        109.99         重庆       30.48

来源：经纬度在线查询、国家统计局

### 5.2.3 模型建立

考虑中间节点的连接情况，
将中间节点涉及到的链接标记为特殊链接，故染色体编码将会增加一倍。此外，每个节点网络的单波传输容量是有限制的，构成选择下一代的约束条件。利用遗传算法解决光传输线路规划问题时，模型建立如下：

1.  染色体编码

12个城市点两两相连，且有可能存在中间节点，此时单个个体基因总数为276个，基因段的编码可分为三个部分，如图5.5所示。

1)  对66条连接链路进行1-66的编号，将66个编号随机放入线路编码中的66位置中；

2)  假设最高重复度为4，第二段的编码的66位表示1-66条线路对应的重复度，随机生成0-4的整数放入基因位中，就表示一个基因位的线路重复的次数；

3)  12条线路有122个容量，随机生成0-1的数，再经过一定的处理，可以表示每个城市点的容量分配以及每条线路的速率分配。

图5.5 基因段编码分段

2.  初始种群

初始种群的产生依赖于随机函数，在该模型中一个个体是由276个基因组成。假设该模型中初始种群的数量为100，则剩下的99个个体用同样的方式生成。

3.  适应度函数

增加中间节点后的适应度函数比较复杂，在原基础求解网络价值的基础上，要加上关于中间节点的约束条件，此时的适应度函数基本分为四个步骤：

1)  利用Dijkstra算法对种群进行筛选，使满足所有城市点遍历的个体进入下一步；

2)  若连接数为16，累加基因编码中的第二部分，直到累加和大于16时停止。根据线路连接，若非两点直连，则寻找最近的中间节点，使这两点实现连接；

3)  根据两点之间的距离分配线路速率以及城市点的设备容量

4)  利用公式（5.3）计算此时网络的价值。

<!-- -->

(4) 遗传算子

对于选择算子，同样采用轮盘赌选择法；

对于交叉算子，由于每个个体的基因数量较多，因此采用多点交叉的方法使三个对应的编码区域实现对应的交叉；

> 对于变异算子，同样要使三个区域内的基因均可以发生变异。

### 5.2.4 模型求解

根据网络价值的模型，可以在MATLAB中实现对光传送网的规划。当城市点连接数n=16时，其规划具体路线如图5.6(a)所示，此时最大网络价值为：2731.5505mTb/s；而随着迭代次数的增加，城市网络价值的变化曲线如图5.6(b)所示，迭代次数在250次左右时，网络价值趋于最优。

![](media/image43.png){width="3.461038932633421in"
height="2.1088735783027124in"}

(a) 网络线路规划图

![](media/image44.png){width="3.4563670166229223in"
height="1.9811898512685915in"}

(b) 迭代次数与网络价值的关系

图5.6 n=16时网络规划

根据定义的变量得出各个城市点的邻接矩阵，如表7所示。结合表格的横纵数值对比分析，可以分析出网络规划图的路线。

表7 n=16各城市点的邻接矩阵

       1   2   3   4   5   6   7   8   9   10   11   12
  ---- --- --- --- --- --- --- --- --- --- ---- ---- ----
  1    0   0   0   1   0   0   1   0   0   0    0    1
  2    0   0   0   0   3   2   0   0   0   0    0    0
  3    0   0   0   0   2   0   1   0   0   1    1    0
  4    1   0   0   0   0   0   0   0   1   0    0    0
  5    0   3   2   0   0   0   0   0   0   0    0    1
  6    0   2   0   0   0   0   0   0   0   0    0    0
  7    1   0   1   0   0   0   0   1   0   0    0    0
  8    0   0   0   0   0   0   1   0   0   0    0    0
  9    0   0   0   1   0   0   0   0   0   0    0    0
  10   0   0   1   0   0   0   0   0   0   0    0    0
  11   0   0   1   0   0   0   0   0   0   0    0    0
  12   1   0   0   0   1   0   0   0   0   0    0    0

当城市点连接数n=33时，其规划具体路线如图5.7(a)所示，此时最大网络价值为：7318.3339mTb/s。而随着迭代次数的增加，城市网络价值的变化曲线如图5.7(b)所示，迭代次数在40次左右时的网络价值趋于最优。

![](media/image45.png){width="3.5454549431321083in"
height="2.001094706911636in"}

a)  网络线路规划图

![](media/image46.png){width="3.578665791776028in"
height="2.2188932633420824in"}

b)  迭代次数与网络价值的关系

图5.7 n=33时网络规划

同理，根据定义的变量得出各个城市点的邻接矩阵，如表8所示。结合表格的横纵数值对比分析，可以分析出网络规划图的路线。表格中的"2"、"3"表示该条线路是一个中间路段，该线路被利用了两次或三次。

表8 n=33各城市点的邻接矩阵

       1   2   3   4   5   6   7   8   9   10   11   12
  ---- --- --- --- --- --- --- --- --- --- ---- ---- ----
  1    0   0   0   1   0   0   1   0   0   0    0    1
  2    0   0   0   0   3   2   0   0   0   0    0    0
  3    0   0   0   0   2   0   1   0   0   1    1    0
  4    1   0   0   0   0   0   0   0   1   0    0    0
  5    0   3   2   0   0   0   0   0   0   0    0    1
  6    0   2   0   0   0   0   0   0   0   0    0    0
  7    1   0   1   0   0   0   0   1   0   0    0    0
  8    0   0   0   0   0   0   1   0   0   0    0    0
  9    0   0   0   1   0   0   0   0   0   0    0    0
  10   0   0   1   0   0   0   0   0   0   0    0    0
  11   0   0   1   0   0   0   0   0   0   0    0    0
  12   1   0   0   0   1   0   0   0   0   0    0    0

当城市点由市扩大到省（区）时，关键改变的是人口数量。当城市点连接数n=16时，其规划具体路线如图5.8(a)所示，此时最大网络价值为：20998.8581mTb/s。而随着迭代次数的增加，城市网络价值的变化曲线如图5.8(b)所示，迭代次数在480次左右时的网络价值趋于最优。

![](media/image47.png){width="4.539130577427821in"
height="2.4854286964129484in"}

a)  网络线路规划图

![](media/image48.png){width="4.243477690288714in"
height="2.6612423447069116in"}

b)  迭代次数与网络价值的关系

图5.8 n=16时网络规划

根据定义的变量得出各个城市点的邻接矩阵，如表9所示。结合表格的横纵数值对比分析，可以分析出网络规划图的路线。

表9 n=16各城市点的邻接矩阵

       1   2   3   4   5   6   7   8   9   10   11   12
  ---- --- --- --- --- --- --- --- --- --- ---- ---- ----
  1    0   4   4   0   0   4   0   0   0   0    0    0
  2    4   0   0   0   0   0   0   0   0   0    0    0
  3    4   0   0   0   0   0   0   0   0   0    0    0
  4    0   0   0   0   0   0   4   0   0   0    0    2
  5    0   0   0   0   0   1   0   4   0   1    0    0
  6    4   0   0   0   1   0   0   0   0   0    0    0
  7    0   0   0   4   0   0   0   0   0   0    0    0
  8    0   0   0   4   0   0   0   0   0   0    0    0
  9    0   0   0   0   0   0   0   0   0   4    0    0
  10   0   0   0   0   1   0   0   0   4   0    4    4
  11   0   0   0   0   0   0   0   0   0   4    0    4
  12   0   0   0   2   0   0   0   0   0   4    4    0

当城市点连接数n=33时，其规划具体路线如图5.9(a)所示，此时最大网络价值为：20998.8581mTb/s。而随着迭代次数的增加，城市网络价值的变化曲线如图5.9(b)所示，迭代次数在480次左右时的网络价值趋于最优。

![](media/image49.png){width="4.079213692038495in"
height="2.5204101049868766in"}

a)  网络线路规划图

![](media/image50.png){width="4.079078083989502in"
height="2.3941130796150483in"}

c)  迭代次数与网络价值的关系

图5.9 n=33时网络规划

根据定义的变量得出各个城市点的邻接矩阵，如表10所示。结合表格的横纵数值对比分析，可以分析出网络规划图的路线。

表10 n=33各城市点的邻接矩阵

       1   2   3   4   5   6   7   8   9   10   11   12
  ---- --- --- --- --- --- --- --- --- --- ---- ---- ----
  1    0   4   4   0   0   4   0   0   0   0    0    0
  2    4   0   0   0   0   0   0   0   0   0    0    0
  3    4   0   0   0   0   0   0   0   0   0    0    0
  4    0   0   0   0   0   0   4   0   0   0    0    2
  5    0   0   0   0   0   1   0   4   0   1    0    0
  6    4   0   0   0   1   0   0   0   0   0    0    0
  7    0   0   0   4   0   0   0   0   0   0    0    0
  8    0   0   0   0   4   0   0   0   0   0    0    0
  9    0   0   0   0   0   0   0   0   0   4    0    0
  10   0   0   0   0   1   0   0   0   4   0    4    4
  11   0   0   0   0   0   0   0   0   0   4    0    4
  12   0   0   0   2   0   0   0   0   0   4    4    0

5.3 子问题-3：多约束多目标网络规划及其价值
------------------------------------------

### 5.3.1 问题分析

本问题要求考虑不同角度分析光传输网络价值，属于多目标优化问题。连接经济发达地区会带来更多的收入，连接发展相对滞后地区可以保障国家通信均衡发展。我队认为，从运营商角度考虑时，可以将城市的GDP来衡量其经济发展状况，从而产生不同的权重。我队选择GDP的理由是，某城市GDP根据**收入法**，其计算公式如下：

GDP=工资+利息+利润+租金+简介税和企业转移支付+折旧 (5.6)

这一等式计算的得来的，基本代表某城市经济状况，可以用做对不同城市经济发展状况的概括。从政府角度出发，为了使发展相对滞后地区的通信状况能够均衡发展，我队拟优先保证12个城市均连接在网络传输路线中。因此我队拟制定光传送网络规划的目标应该是保障国家通信均衡发展的前提下，再考虑如何取得更多的网络价值。故可以将本问题多目标优化问题分成两个单目标优化问题：**第一部分**是将保障国家通信均衡发展问题，从另一个角度思考，转化为在保证网络**连接网中网孔数量尽可能多**的情况下，求解网络价值最大；**第二部分**是在第一部分的基础上，结合第二问建立的模型，增加不同城市点之间**经济状况的得出的权值**，再使网络价值达到最大的网络规划。

### 5.3.2 模型建立

第一部分的问题：网络连接网中网孔数量的求解。该问题可以类比电路图中网孔数量的计算方法，得到网络图中网孔的数量。使下代网孔数量不减少，同时保证每个节点都被联通，可以解决题目中提到的保障发展相对滞后地区的通信是均衡发展的。

第二部分问题的解决前提是先确定地区经济发展程度。类比题中所定义的两城市的之间的连接线路人口的计算，我队拟假设两城市点连接线路的权重取两城市点GDP总数乘积的0.5次方，再通过归一化处理后作为该城市的经济发展权重，以此来衡量城市经济发展程度。例如：城市i和城市j的经济发展权重分别为$\text{Eco}_{i}$和$\text{Eco}_{j}$，则两座城市链路连接价值为：

$\text{NV}_{\text{ij}} = {\sqrt{\text{Eco}_{i} \times \text{Eco}_{j} \times}\text{Cap}}_{\text{ij}} \times \sqrt{\text{Num}_{i} \times \text{Num}_{j}}\ i,j = 1,2,\ldots,12$
(5.7)

因此，在前两问的基础上，结合此问中的权重，该问中光传送网络回话的目标函数为：

$\text{MAX\ }\text{NV}_{\text{Total}} = \sum_{}^{}\text{NV}_{\text{ij}}$
(5.8)

从而网络目标函数是所有链路连接价值的加权和：

$\text{MAX\ }\text{NV}_{\text{Total}} = \sum_{}^{}\text{NV}_{\text{ij}}，\ \ \ \ \ \ \ (i,j = 1,2,\ldots,12)$
(5.9)

### 5.3.3 模型求解

本题中求解出的城市链路权重如表11所示。

表11 城市链路权重表

             北京天津   哈尔滨   上海     郑州     武汉     广州深圳   重庆     西安     昆明     成都     拉萨     乌鲁木齐
  ---------- ---------- -------- -------- -------- -------- ---------- -------- -------- -------- -------- -------- ----------
  北京天津              0.3766   0.8042   0.4396   0.5363   0.9694     0.6474   0.3933   0.3228   0.5460   0.1013   0.2451
  哈尔滨                         0.3029   0.1655   0.2020   0.3651     0.2438   0.1481   0.1216   0.2056   0.0381   0.0923
  上海                                    0.3535   0.4313   0.7796     0.5206   0.3163   0.2596   0.4391   0.0815   0.1971
  郑州                                             0.2357   0.4261     0.2846   0.1729   0.1419   0.2400   0.0445   0.1077
  武汉                                                      0.5199     0.3472   0.2109   0.1731   0.2928   0.0543   0.1314
  广州深圳                                                             0.6276   0.3813   0.3129   0.5293   0.0982   0.2376
  重庆                                                                          0.2547   0.2090   0.3535   0.0656   0.1587
  西安                                                                                   0.1270   0.2148   0.0398   0.0964
  昆明                                                                                            0.1763   0.0327   0.0791
  成都                                                                                                     0.0553   0.1338
  拉萨                                                                                                              0.0248
  乌鲁木齐                                                                                                          

数据来源：国家统计局，经过归一处理完成

得到城市链路经济权重表之后，更新网络价值的公式。满足第一部分问题的网络连接图的约束条件，记录前一代个体的网孔数量，当当前代的网孔数量比前一代数量减少时，对该个体进行惩罚，使其适应度为0，网孔数量相等或增加时进行保留。采用遗传算法，并应用该适应度函数后，得到最大的网络价值及网络连接图。

当城市点连接数n=16时，其规划具体路线如图5.8(a)所示，此时最大网络价值为：2359.2138mTb/s；而随着迭代次数的增加，城市网络价值的变化曲线如图5.8(b)所示，迭代次数在450次左右时，网络价值趋于最优。

![](media/image51.png){width="3.6956517935258093in"
height="2.28920384951881in"}

(a) 网络线路规划图

![](media/image52.png){width="3.643478783902012in"
height="2.2959273840769905in"}

(b) 迭代次数与网络价值的关系

图5.8 n=16时网络规划

同理，根据定义的变量得出各个城市点的邻接矩阵，如表12所示。结合表格的横纵数值对比分析，可以分析出网络规划图的路线。表格中的"2"、"3"表示该条线路是一个中间路段，该线路被利用了两次或三次。

表12 n=16各城市点的邻接矩阵

       1   2   3   4   5   6   7   8   9   10   11   12
  ---- --- --- --- --- --- --- --- --- --- ---- ---- ----
  1    0   3   0   0   0   0   0   0   0   0    0    3
  2    3   0   0   4   0   0   0   0   0   0    0    0
  3    0   0   0   0   1   0   0   0   0   0    0    0
  4    0   4   0   0   0   0   0   0   0   3    0    0
  5    0   0   1   0   0   0   0   3   0   0    0    0
  6    0   0   0   0   0   0   3   0   0   0    0    0
  7    0   0   0   0   0   3   0   0   2   0    1    0
  8    0   0   0   0   3   0   0   0   0   0    1    0
  9    0   0   0   0   0   0   0   0   0   3    0    0
  10   0   0   0   3   0   3   0   0   3   0    3    0
  11   0   0   0   0   0   0   0   1   0   3    0    0
  12   3   0   0   0   0   0   0   0   0   0    0    0

当城市点连接数n=16时，其规划具体路线如图5.8(a)所示，此时最大网络价值为：4351.0578mTb/s；而随着迭代次数的增加，城市网络价值的变化曲线如图5.8(b)所示，迭代次数在240次左右时，网络价值波动虽然没有稳定在一定的数值，但是波动情况较小，即将趋于稳定。

![](media/image53.png){width="4.156521216097988in"
height="2.310457130358705in"}

(a) 网络线路规划图

![](media/image54.png){width="4.182459536307961in"
height="2.454286964129484in"}

(b) 迭代次数与网络价值的关系

图5.8 n=33时网络规划

同理，根据定义的变量得出各个城市点的邻接矩阵，如表13所示。结合表格的横纵数值对比分析，可以分析出网络规划图的路线。表格中的"2"、"3"表示该条线路是一个中间路段，该线路被利用了两次或三次。

表13 n=16各城市点的邻接矩阵

       1   2   3   4   5   6   7   8   9   10   11   12
  ---- --- --- --- --- --- --- --- --- --- ---- ---- ----
  1    0   4   0   0   0   0   0   0   0   0    0    0
  2    4   0   0   4   4   4   0   0   0   0    0    0
  3    0   0   0   0   0   0   0   0   0   0    4    0
  4    0   4   0   0   0   4   4   0   0   0    0    4
  5    0   4   0   0   0   0   0   0   0   0    0    0
  6    0   4   0   4   0   0   3   0   0   3    4    0
  7    0   0   0   4   0   3   0   0   0   0    0    0
  8    0   0   0   0   0   0   0   0   3   0    0    4
  9    0   0   0   0   0   0   0   3   0   0    0    0
  10   0   0   0   0   0   3   0   0   0   0    2    0
  11   0   0   4   0   0   4   0   0   0   2    0    0
  12   0   0   0   4   0   0   0   4   0   0    0    0

 六、问题三：改进调制格式
=========================

6.1 问题分析
------------

根据第一问的结果，光纤传输链路的长度与SNR容限点有关。在纠前BER不变的情况下，若SNR容限点越低，链路系统容忍噪声的能力越强，那么链路的长度越长。因此在问题三中，探讨改变16QAM方案中星座点的位置、数量或每个点的概率，来获得一个比问题一中8QAM中具有更低SNR容限点的调制方式。同时该问题还引入了信息熵的概念，信息熵^\[8\]^是计算机中的概念，将信源的平均不定度用概率分布来度量。根据式(1.9)信息熵的定义，要使信息熵保持不变，可以通过减少星座点数量或者减小星座点的概率来实现。但在本问题中，假定使信息熵保持为3bit时星座点的个数是8个，由信息熵定义可知每个点的概率也恒定保持不变。因此，要使SNR容限点更低，只需要考虑星座点的位置，通过遗传算法寻找星座点的最优位置，使新的调制方案的SNR容限点最低^\[9\]^。

6.2 模型建立
------------

问题三模型的建立相较于问题二比较容易，首先8QAM的星座点可直接作为一个初始种群个体的基因，其次适应度函数满足相邻两点的距离最大。遗传算法建模如下：

(1) 染色体编码

8QAM的8个星座点即可当做遗传算法中的基因，在坐标平面内，分别以x、y轴上\[-1,1\]组成的正方形为星座点随机生成的区域空间，在此区间随机生成的一个复数就代表一个基因，8个星座点对应一个个体的8个基因。

(2) 初始种群

遗传算法的初始种群是20个个体，每个个体的基因是需要改善的8QAM的8个星座点，在上述区域中随机生成8个复数即为一个个体的8个基因，随机产生的20个个体构成一个初始种群。

(3) 适应度函数

> 该模型的适应度函数是对相邻两点间的距离作出评价，具体步骤可以分为：

1)  求八个点中两两个节点的距离，并找到最小距离；

2)  将这八个点的坐标除以最小距离，得出新的八个坐标点，对这八个新坐标点取模$\rightarrow$平方$\rightarrow$取均值$\rightarrow$求倒数，得出一个价值数值；

3)  依次类推，产生20个价值数值，即为所求的适应度。

<!-- -->

(4) 遗传算子

对于选择算子，同样采用轮盘赌选择法，择出最高价值的个体进行交叉变异进入下一代；

对于交叉算子，由于个体中的基因数量较少，一次采用单点交叉较合理；

对于变异算子，采用基本变异，只要能够保持种群基因的多样性就能够满足条件。

6.3 模型求解
------------

如下图6.1所示为遗传算法迭代产生的新的8QAM调制方案。

![](media/image55.png){width="3.765217629046369in"
height="3.007730752405949in"}

图6.1改善后8QAM调制方案

图6.2、6.3为改善前后的发送与接收星座图，从下图可以看出，改善后的8QAM星座图构成一个心形(横型)。

![](media/image56.png){width="4.354971566054243in"
height="2.3851148293963256in"}

图6.2 改善前8QAM星座图

![](media/image57.png){width="4.4157305336832895in"
height="2.330997375328084in"}

图6.3 改善后8QAM星座图

迭代次数与适应度关系曲线如图6.4所示，经过两万次迭代后，适应度基本稳定，并随着迭代次数逐渐缓慢增长，并且评价值稳定在0.7以上。表明遗传算法对该问题有效。

![](media/image58.png){width="4.747825896762905in"
height="2.9941141732283465in"}

图6.4 迭代次数与适应度关系曲线

如图6.5所示，改善后的8QAM调制方案比改善前具有更低的SNR容限点，可以提高系统容忍噪声的能力，从而延长链路的总长度。

![](media/image59.png){width="4.742531714785652in"
height="3.0964063867016622in"}

图6.5 改善前后8QAM调制方案BER与SNR关系曲线

参考文献
========

\[1\]石悦，邱雪松等人.基于改进遗传算法的电力光传输网规划方法\[J\].通信学报：2016
, 37 (1) :116-122.

\[2\]张公礼,刘俊霞,罗宏杰.采用8QAM调制的GSM/EDGE移动通信系统\[J\].电子器件,2008(03):887-889.

\[3\]
褚衍杰,胡年福,巢凯今,彭晓成.通带MQAM信号调制方式识别方法\[J\].西安电子科技大学学报,2008(05):932-937.

\[4\] 孔五艳. MQAM信号调制识别技术研究\[D\].苏州大学,2013.

\[5\]刘继红，李佳泯，梁猛.16-QAM相干光纤通信系统星座图的优化与选择\[J\].半导体光电：2012
, 33 (1) :110-112.

\[6\]魏全新，刘贤锋等人.遗传算法选择方法的比较分析\[J\].《通讯和计算机:中英文版》,
2008 (8) :61-65.

\[7\]卢金. 基于遗传算法的光传送网络空闲资源优化设计\[D\].吉林大学，2006.

\[8\]百度百科：https://baike.so.com/doc/6616826-6830620.html.

\[9\]豆丁网：http://www.docin.com/p-977362927-f2.html

附录
====

**问题1-1代码**

clear all;

close all;

\%假设传输10000个符号

N\_symbol=10000;

for snrdb=1:1:25

\%%%%%%%%%%%%%%%%%%%%qpsk原始信号%%%%%%%%%%%%%%

\%qpsk原始二进制位流

si\_qpsk=(1/(2\^(1/2)))\*2\*(round(rand(1,N\_symbol))-0.5);

sq\_qpsk=(1/(2\^(1/2)))\*2\*(round(rand(1,N\_symbol))-0.5);

s\_qpsk=si\_qpsk + 1i\*sq\_qpsk;

\%%%%%%%%%%%%%%%%%8qam原始信号%%%%%%%%%%%%%%%%%

dot\_8qam = \[1+1j -1+1j -1-1j 1-1j 1i\*3 -1i\*(1+3\^(1/2)) (1+3\^(1/2))
-(1+3\^(1/2))\]; %8qam星座映射点

\%产生符号序列% 映射16qam

rand0\_7 = randi(8,1,N\_symbol);

s\_8qam = zeros(1,N\_symbol);

for a=1:N\_symbol

s\_8qam(1,a)=dot\_8qam(1,rand0\_7(1,a));

end

\%8qam原始二进制位流

s\_8qam\_oct=qamdemod\_8qam(s\_8qam,8); %此时解调出来的是8进制信号

s\_8qam\_bit\_stream=de2bi(s\_8qam\_oct,3,\'left-msb\');
%转化为对应的二进制比特流

s\_8qam\_bit\_stream=reshape(s\_8qam\_bit\_stream.\',numel(s\_8qam\_bit\_stream),1\');

\%%%%%%%%%%%%%%%%%%16qam原始信号%%%%%%%%%%%%%%

dot\_16qam = \[1+1j -1+1j -1-1j 1-1j 3+1j 3+3j 1+3j -1+3j -3+3j -3+1j
-3-1j -3-3j -1-3j 1-3j 3-3j 3-1j\]; %16qam星座映射点

\%产生符号序列% 映射16qam

rand0\_15 = randi(16,1,N\_symbol);

s\_16qam = zeros(1,N\_symbol);

for a=1:N\_symbol

s\_16qam(1,a)=dot\_16qam(1,rand0\_15(1,a));

end

\%16qam原始二进制位流

s\_16qam\_hex=demodulate(modem.qamdemod(16),s\_16qam);
%此时解调出来的是16进制信号

s\_16qam\_bit\_stream=de2bi(s\_16qam\_hex,4,\'left-msb\');
%转化为对应的二进制比特流

s\_16qam\_bit\_stream=reshape(s\_16qam\_bit\_stream.\',numel(s\_16qam\_bit\_stream),1\');

\%%%%%%%%%%%%%%%%加高斯白噪声%%%%%%%%%%%%%%%%%%

\%qpsk加高斯白噪声

w\_qpsk = awgn(s\_qpsk,snrdb,\'measured\');

r\_qpsk = w\_qpsk;

\%8qam加高斯白噪声

w\_8qam = awgn(s\_8qam,snrdb,\'measured\');

r\_8qam = w\_8qam;

\%16qam加高斯白噪声

w\_16qam = awgn(s\_16qam,snrdb,\'measured\');

r\_16qam = w\_16qam;

\%对加噪声之后的信号计算误码率

\%qpsk BER

si\_\_qpsk=sign(real(r\_qpsk));

sq\_\_qpsk=sign(imag(r\_qpsk));

ber1\_qpsk=(N\_symbol-sum((si\_qpsk/(1/(2\^(1/2))))==si\_\_qpsk))/N\_symbol;

ber2\_qpsk=(N\_symbol-sum((sq\_qpsk/(1/(2\^(1/2))))==sq\_\_qpsk))/N\_symbol;

ber\_qpsk(snrdb)=mean(\[ber1\_qpsk ber2\_qpsk\]);

\%8qam BER

r\_8qam\_oct=qamdemod\_8qam(r\_8qam,8); %此时解调出来的是8进制信号

r\_8qam\_bit\_stream=de2bi(r\_8qam\_oct,3,\'left-msb\');
%转化为对应的二进制比特流

r\_8qam\_bit\_stream=reshape(r\_8qam\_bit\_stream.\',numel(r\_8qam\_bit\_stream),1\');

ber\_8qam(snrdb)=biterr(s\_8qam\_bit\_stream,r\_8qam\_bit\_stream)/(N\_symbol\*3);

\%16qam BER

r\_16qam\_hex=demodulate(modem.qamdemod(16),r\_16qam);
%此时解调出来的是16进制信号

r\_16qam\_bit\_stream=de2bi(r\_16qam\_hex,4,\'left-msb\');
%转化为对应的二进制比特流

r\_16qam\_bit\_stream=reshape(r\_16qam\_bit\_stream.\',numel(r\_16qam\_bit\_stream),1\');

ber\_16qam(snrdb)=biterr(s\_16qam\_bit\_stream,r\_16qam\_bit\_stream)/(N\_symbol\*4);

end

\%QPSK星座图

figure(1);clf;hold on;

subplot(1,2,1);plot(s\_qpsk,\'b.\');title(\'QPSK发射星座图\');axis
equal;axis(\[-2 2 -2 2\])

subplot(1,2,2);plot(r\_qpsk,\'b.\');title(\'QPSK接收星座图(25db)\');axis
equal;axis(\[-2 2 -2 2\])

\%8qam星座图

hold on;

figure(2);clf;hold on;

subplot(1,2,1);plot(s\_8qam,\'b.\');title(\'8QAM发射星座图\');axis
equal;axis(\[-5 5 -5 5\])

subplot(1,2,2);plot(r\_8qam,\'b.\');title(\'8QAM接收星座图(25db)\');axis
equal;axis(\[-5 5 -5 5\])

\%16qam星座图

figure(3);

clf; hold on;

subplot(1,2,1);plot(s\_16qam,\'b.\');title(\'16QAM发射星座图\');axis
equal;axis(\[-5 5 -5 5\])

subplot(1,2,2);plot(r\_16qam,\'b.\');title(\'16QAM接收星座图(25db)\');axis
equal;axis(\[-5 5 -5 5\])

\%%%%%%%%%%%%%%%%qpsk 8qam 16qam BER-SNR图%%%%%%%%%

figure(4);

snrdb=1:1:25;

semilogy(snrdb,ber\_qpsk,\'-bo\',snrdb,ber\_8qam,\'-mh\',snrdb,ber\_16qam,\'-gd\',snrdb,0.02\*ones(size(snrdb)),\'r\--\',\'linewidth\',2)

title(\'QPSK 8QAM 16QAM with awgn\');

xlabel(\'Signal to noise ratio\');

ylabel(\'Bit error rate\');

legend(\'QPSK\',\'8QAM\',\'16QAM\');

axis(\[-2 25 -5 2\]);

grid on;

function \[out\] = qamdemod\_8qam(In,mod)

switch mod

case 8

Symmbol\_8qam = \[1+1j -1+1j -1-1j 1-1j 1i\*3 -1i\*(1+3\^(1/2))
(1+3\^(1/2)) -(1+3\^(1/2))\];

for a=1:length(In)

distance = abs(Symmbol\_8qam-In(a));

\[\~,Ind\] = min(distance);

out(a) = Ind-1;

end

end

end

**问题1-2代码**

clear all;

close all;

clc;

\%假设传输10000个符号

N\_symbol=10000;

\%放大器自发辐射噪声

\%常数

h = 6.62606896\*(1e-34);

f = 193e12;

B = 50e9;

NF = 4;

\%符号单位功率

Transmit\_Power = 1e-3;

Transmit\_Amp = sqrt(Transmit\_Power);

Span\_num = (10:10:250);

\%%%%%%%%%%%%%%%%%%%%%%%%%80km为一跨%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

One\_span\_distance = 80; %单位km

for span\_i=1:length(Span\_num)

\%%%%%%%%%%%%%%%%%%%%%%%qpsk原始信号%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\%qpsk原始二进制位流

si\_qpsk=(1/(2\^(1/2)))\*2\*(round(rand(1,N\_symbol))-0.5);

sq\_qpsk=(1/(2\^(1/2)))\*2\*(round(rand(1,N\_symbol))-0.5);

s\_qpsk=si\_qpsk + 1i\*sq\_qpsk;

s\_qpsk = s\_qpsk\*Transmit\_Amp;

\%%%%%%%%%%%%%%%%%%%%%%%%8qam原始信号%%%%%%%%%%%%%%%%%%%%%%%%%%%

dot\_8qam = \[1+1j -1+1j -1-1j 1-1j 1i\*3 -1i\*(1+3\^(1/2)) (1+3\^(1/2))
-(1+3\^(1/2))\]; %8qam星座映射点

\%产生符号序列% 映射16qam

rand0\_7 = randi(8,1,N\_symbol);

s\_8qam = zeros(1,N\_symbol);

for a=1:N\_symbol

s\_8qam(1,a)=dot\_8qam(1,rand0\_7(1,a));

end

\%8qam原始二进制位流

s\_8qam\_oct=qamdemod\_8qam(s\_8qam,8); %此时解调出来的是8进制信号

s\_8qam\_bit\_stream=de2bi(s\_8qam\_oct,3,\'left-msb\');
%转化为对应的二进制比特流

s\_8qam\_bit\_stream=reshape(s\_8qam\_bit\_stream.\',numel(s\_8qam\_bit\_stream),1\');

s\_8qam = s\_8qam\*Transmit\_Amp;

\%%%%%%%%%%%%%%%%%%%16qam原始信号%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

dot\_16qam = \[1+1j -1+1j -1-1j 1-1j 3+1j 3+3j 1+3j -1+3j -3+3j -3+1j
-3-1j -3-3j -1-3j 1-3j 3-3j 3-1j\]; %16qam星座映射点

\%产生符号序列% 映射16qam

rand0\_15 = randi(16,1,N\_symbol);

s\_16qam = zeros(1,N\_symbol);

for a=1:N\_symbol

s\_16qam(1,a)=dot\_16qam(1,rand0\_15(1,a));

end

\%16qam原始二进制位流

s\_16qam\_hex=demodulate(modem.qamdemod(16),s\_16qam);
%此时解调出来的是16进制信号

s\_16qam\_bit\_stream=de2bi(s\_16qam\_hex,4,\'left-msb\');
%转化为对应的二进制比特流

s\_16qam\_bit\_stream=reshape(s\_16qam\_bit\_stream.\',numel(s\_16qam\_bit\_stream),1\');

s\_16qam = s\_16qam\*Transmit\_Amp;

\%%%%%%%%%%%%%%%%%%%%%%%%%%%%经跨传输%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

r\_qpsk =
span(s\_qpsk,One\_span\_distance,Span\_num(span\_i),h,f,B,NF)/Transmit\_Amp;

r\_8qam =
span(s\_8qam,One\_span\_distance,Span\_num(span\_i),h,f,B,NF)/Transmit\_Amp;

r\_16qam =
span(s\_16qam,One\_span\_distance,Span\_num(span\_i),h,f,B,NF)/Transmit\_Amp;

\%经跨段传输之后的信号计算误码率

\%qpsk BER

si\_\_qpsk=sign(real(r\_qpsk));

sq\_\_qpsk=sign(imag(r\_qpsk));

ber1\_qpsk=(N\_symbol-sum((si\_qpsk/(1/(2\^(1/2))))==si\_\_qpsk))/N\_symbol;

ber2\_qpsk=(N\_symbol-sum((sq\_qpsk/(1/(2\^(1/2))))==sq\_\_qpsk))/N\_symbol;

ber\_qpsk(span\_i)=mean(\[ber1\_qpsk ber2\_qpsk\]);

\%8qam BER

r\_8qam\_oct = qamdemod\_8qam(r\_8qam,8); %此时解调出来的是8进制信号

r\_8qam\_bit\_stream=de2bi(r\_8qam\_oct,3,\'left-msb\');
%转化为对应的二进制比特流

r\_8qam\_bit\_stream=reshape(r\_8qam\_bit\_stream.\',numel(r\_8qam\_bit\_stream),1\');

ber\_8qam(span\_i)=biterr(s\_8qam\_bit\_stream,r\_8qam\_bit\_stream)/(N\_symbol\*3);

\%16qam BER

r\_16qam\_hex=demodulate(modem.qamdemod(16),r\_16qam);
%此时解调出来的是16进制信号

r\_16qam\_bit\_stream=de2bi(r\_16qam\_hex,4,\'left-msb\');
%转化为对应的二进制比特流

r\_16qam\_bit\_stream=reshape(r\_16qam\_bit\_stream.\',numel(r\_16qam\_bit\_stream),1\');

ber\_16qam(span\_i)=biterr(s\_16qam\_bit\_stream,r\_16qam\_bit\_stream)/(N\_symbol\*4);

end

figure(1);clf;hold on;

plot(Span\_num,ber\_qpsk,\'r-\*\');

plot(Span\_num,ber\_8qam,\'b-o\');

plot(Span\_num,ber\_16qam,\'k-x\');

plot(Span\_num,0.02\*ones(size(Span\_num)),\'r\--\',\'linewidth\',2);

legend(\'QPSK\',\'8QAM\',\'16QAM\',\'Ber门限值\');

xlabel(\'光纤段数\');ylabel(\'ber\');

title(\'光纤长度 80Km\');

set(gca,\'yscale\',\'log\');

grid on; box on;

function \[Out\] = qamdemod\_8qam(In,mod)

switch mod

case 8

ModSymmbol = \[1+1j -1+1j -1-1j 1-1j 1i\*3 -1i\*(1+3\^(1/2))
(1+3\^(1/2)) -(1+3\^(1/2))\];

for a=1:length(In)

Dis = abs(ModSymmbol-In(a));

\[\~,Ind\] = min(Dis);

Out(a) = Ind-1;

end

end

end

function out = span(sgl,One\_span,Span\_num,h,f,B,NF)

sgl\_tmp=sgl;

for a=1:Span\_num

sgl\_tmp=span\_opt(sgl\_tmp,One\_span,h,f,B,NF);

end

out = sgl\_tmp;

end

function out = span\_opt(sgl,One\_span,h,f,B,NF)

\%计算光纤的衰减和Gain值

Loss\_dB = 3\*(One\_span/15000);

Loss = 10\^(Loss\_dB/10);

Gain = 1/Loss;

\%线性噪声功率

Pn = 2\*pi\*h\*f\*B\*(NF+1/Gain);

InPow = mean(sgl.\^2)/1e3;

Pno = 2\*pi\*h\*f\*B\*NF;

\%非线性噪声功率

Pnnl = (InPow/(1e-3))\^2\*Pno\*2/3;

\%生成入跨信号

NLNoise = (randn(size(sgl))+randn(size(sgl))\*1i)/sqrt(2)\*sqrt(Pnnl);

In2 = sgl + NLNoise;

\%进行衰减和放大

Out1 = In2/Loss\*Gain;

\%放大器噪声

LnaNoise = (randn(size(sgl))+randn(size(sgl))\*1i)/sqrt(2)\*sqrt(Pn);

out = Out1+LnaNoise;

end

**问题2-1主要代码**

clear;clc;close all;

遗传函数参数

Link\_Num = 16;

P\_cross = 0.3; %交叉概率0.3-0.9

P\_mutate = 0.01; %变异概率0.01-0.2

Link\_Num = 33;

P\_cross = 0.3; %交叉概率0.3-0.9

P\_mutate = 0.02; %变异概率0.01-0.2

Initial\_population\_individual\_num = 400; %初始种群的个体数量

Max\_generation = 500; %最大代数

\%目标连接数

Link\_Num = 16;

\%城市信息

City\_Num = 12;

\%总可连接数

Link\_Num\_Total=(City\_Num-1) \* City\_Num/2;

City\_Name = \[\"哈尔滨\",\"北京&天津\", \"郑州\", \"上海\", \"武汉\",
\"广州&深圳\", \"西安\", \"乌鲁木齐\", \"拉萨\", \"成都\", \"昆明\",
\"重庆\"\];

City\_Population = \[9.9526 34.8245 9.03 23.8043 10.12 23.3853 8.83 3.8
0.9025 16.0477 7.2131 8.56\];

City\_Locaiton=\[45.8 126.53;39.92 116.46;34.75 113.66;31.23 121.47;30.6
114.3;23.13 113.27;34.27 108.93;43.82 87.62;29.97 91.11;30.67
104.07;25.05 102.72;29.57 106.55\];

\%City\_coordinate为经纬度转换后的坐标

City\_coordinate=city\_information(City\_Locaiton);

\%%%%%%%%%%%%%%%%遗传算法参数%%%%%%%%%%%%%%%%%%

Initial\_population\_individual\_num = 400; %初始种群的个体数量

Max\_generation = 500; %最大代数

P\_cross = 0.3; %交叉概率0.3-0.9

P\_mutate = 0.01; %变异概率0.01-0.2

\%%%%%%%%%%%%%%%%%%产生初始种群%%%%%%%%%%%%%%%%

Initial\_population =
zeros(Initial\_population\_individual\_num,Link\_Num\_Total);

for i=1:Initial\_population\_individual\_num

\%采用tsp编码，即对每条线路进行编码

Initial\_population(i,:) = randperm(Link\_Num\_Total);

end

\%%%%%%%%%%%%%%%%计算种群的适应度%%%%%%%%%%%%%%%

\[\~,P\_popualtion\_distri\]=population\_fitness(Initial\_population,City\_coordinate,City\_Population,Link\_Num);

\%%%%%%%%%%%%%%%%%进化阶段%%%%%%%%%%%%%%%%%%

Evolution\_popualtion = Initial\_population;

generation=1;

Generations\_of\_best\_individual=zeros(Initial\_population\_individual\_num,Link\_Num\_Total);

Population\_cross\_new=zeros(Initial\_population\_individual\_num,Link\_Num\_Total);

Population\_mutate\_new=zeros(Initial\_population\_individual\_num,Link\_Num\_Total);

while generation\<Max\_generation

\%%%%%%%%%%%%%%%%%%%%产生新种群%%%%%%%%%%%%%%%

for j=1:2:Initial\_population\_individual\_num

\%根据种群概率分布进行选择操作

selected\_num=select(P\_popualtion\_distri);

\%交叉

Population\_cross=crossover(Evolution\_popualtion,selected\_num,P\_cross);

Population\_cross\_new(j,:)=Population\_cross(1,:);

Population\_cross\_new(j+1,:)=Population\_cross(2,:);

\%变异

Population\_mutate\_new(j,:)=mutate(Population\_cross\_new(j,:),P\_mutate);

Population\_mutate\_new(j+1,:)=mutate(Population\_cross\_new(j+1,:),P\_mutate);

end

Evolution\_popualtion=Population\_mutate\_new;

\%%%%%%%%%%计算新种群中个体的适应度%%%%%%%%%%%%%%%%%

\[Individual\_fitness,P\_popualtion\_distri\]=population\_fitness(Evolution\_popualtion,City\_coordinate,City\_Population,Link\_Num);

\%记录当代最佳个体的适应度和个体在群落中的位置

\[Best\_fitness\_individual\_value,Best\_fitness\_individual\_num\]=max(Individual\_fitness);
%找出适应度最大的个体

\%记录当前代的最佳个体

Best\_individual=Evolution\_popualtion(Best\_fitness\_individual\_num,:);

\%记录每代最佳个体

Generations\_of\_best\_individual(generation,:)=Best\_individual;

\%记录每代最佳个体的适应度，即总网络价值

Generations\_of\_best\_individual\_fitness(generation) =
Single\_Individual\_fitness(Best\_individual(end,1:Link\_Num),City\_coordinate,City\_Population);

generation=generation+1; %进入下一代

end

function\[Network\_total\_value,City\_connection,City\_Capacity\]=Single\_Individual\_fitness(Single\_individual\_gene,City\_coordinate,City\_Population)

\%解码

\%从66条连接里面找到Link\_Num（16或33）个连接并解码为城市间连接矩阵

City\_Num = size(City\_coordinate,1); %坐标个数%即城市个数

City\_connection = 1-tril(ones(City\_Num,City\_Num),0); %取下三角矩阵

City\_connection = City\_connection(:); %组成一个向量

Ind = find(City\_connection==1); %下三角矩阵元素为1位置索引

City\_connection(Ind)=1:length(Ind); %右上三角递增

for ii=1:length(Single\_individual\_gene)

City\_connection(City\_connection==(Single\_individual\_gene(ii)))=Inf;

end

City\_connection=(City\_connection==Inf);

City\_connection = reshape(City\_connection,City\_Num,City\_Num);

City\_connection = City\_connection + City\_connection\';

\%判断是否连接了所有结点

if (length(TSP(1,City\_connection)) \< City\_Num)

Network\_total\_value =0;

return;

end

\%计算总的网络价值，权值为1

Network\_total\_value = 0;

Max\_trans\_dist\_Req = \[Inf 3000 1200 600\];

Capacity\_Table = \[0 8 16 32\];

City\_Capacity = zeros(City\_Num,City\_Num);

for ii =1:City\_Num

for jj=ii+1:City\_Num

if (City\_connection(ii,jj)\>=1) %如果有连接

Dist= norm(City\_coordinate(ii,:) - City\_coordinate(jj,:));
%两城市间距离

Ind = find(Max\_trans\_dist\_Req\>Dist);

City\_Capacity(ii,jj) = Capacity\_Table(Ind(end));%选择某城市的网络容量

Network\_total\_value = Network\_total\_value +
sqrt(City\_Population(ii)\*City\_Population(jj))\*City\_Capacity(ii,jj);

end

end

end

end

\%%%%%%%%%%%%%%%%%%%%%%表达该网络%%%%%%%%%%%%%

\%计算总价值，城市连接，城市容量

\[Individual\_fitness,City\_connection,City\_Capacity\]=Single\_Individual\_fitness(Generations\_of\_best\_individual(end,1:Link\_Num),City\_coordinate,City\_Population);

\%%%%%%%%%%%%%%%%作图%%%%%%%%%%%%%%%%%%%%%%%

figure(1);

clf;hold on;

\%画城市坐标点

plot(City\_Locaiton(:,2),City\_Locaiton(:,1),\'ko\');

\%显示城市名字

for i= 1:City\_Num

text(City\_Locaiton(i,2),City\_Locaiton(i,1),City\_Name{i},\'fontsize\',18)

end

\%画城市间连线

for ii=1:City\_Num

for jj=1:City\_Num

if (City\_connection(ii,jj)==1)

plot(\[City\_Locaiton(ii,2) City\_Locaiton(jj,2)\],\...

\[City\_Locaiton(ii,1) City\_Locaiton(jj,1)\],\'r\--\');

end

end

end

title(\[\'容量为：\' num2str(Individual\_fitness) \'mTb/s\'\])

ylabel(\'纬度\',\'fontsize\',15);

xlabel(\'经度\',\'fontsize\',15);

figure(2);

plot(Generations\_of\_best\_individual\_fitness);

title(\[\'连接数为：\' num2str(Link\_Num)\]);

ylabel(\'网络价值\',\'fontsize\',15);

xlabel(\'迭代次数\',\'fontsize\',15);

**问题2-2主要代码**

clear ;clc;close all;

\%目标连接数

\%Link\_Num = 16;

Link\_Num = 33;

\%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%城市信息%%%%%%%%%%%%%%%%%%%%%%%%%

City\_Num = 12;

Link\_Num\_Total=(City\_Num-1)\*City\_Num/2;

City\_Name = \[\"哈尔滨\",\"北京&天津\", \"郑州\", \"上海\", \"武汉\",
\"广州&深圳\", \"西安\", \"乌鲁木齐\", \"拉萨\", \"成都\", \"昆明\",
\"重庆\"\];

City\_Population = \[9.9526 34.8245 9.03 23.8043 10.12 23.3853 8.83 3.8
0.9025 16.0477 7.2131 8.56\];

City\_Locaiton=\[45.8 126.53;39.92 116.46;34.75 113.66;31.23 121.47;30.6
114.3;23.13 113.27;34.27 108.93;43.82 87.62;29.97 91.11;30.67
104.07;25.05 102.72;29.57 106.55\];

\%City\_coordinate为经纬度转换后的坐标

City\_coordinate=city\_information(City\_Locaiton);

City\_Dist = zeros(City\_Num,City\_Num);

for ii=1:City\_Num

for jj=1:City\_Num

City\_Dist(ii,jj) = norm(City\_Locaiton(ii,:)-City\_Locaiton(jj,:));

end

end

\%%%%%%%%%%%%%%%%%%%%%%%%%%%%%遗传算法参数%%%%%%%%%%%%%%%%%%%%%%%%%%%

Initial\_population\_individual\_num=100; %初始种群大小

Max\_generation=100; %最大代数

P\_crossover=0.3; %交叉概率

P\_mutate=0.02; %变异概率

\%%%%%%%%%%%%%%%%%%%%%%%%%%%%产生初始种群%%%%%%%%%%%%%%%%%%%%%%%%%%

max\_line = 4;

Code\_Num = Link\_Num\_Total+Link\_Num\_Total+City\_Num\*City\_Num;

Initial\_population=zeros(Initial\_population\_individual\_num,Code\_Num);

for i=1:Initial\_population\_individual\_num

si=randperm(Link\_Num\_Total);

sid=randi(\[1 max\_line\],1,Link\_Num\_Total);

xx = rand(City\_Num,City\_Num);

xx = xx/sum(xx(:));

Initial\_population(i,:) = Code(si,sid,xx);

end

\%%%%%%%%%%%%%%%%%%%%%%%%%%%计算种群的适应度%%%%%%%%%%%%%%%%%%%%%%%%

\[\~,P\_popualtion\_distri\]=population\_fitness(Initial\_population,City\_coordinate,City\_Dist,City\_Population,Link\_Num);

\%%%%%%%%%%%%%%%%%%%%%%%%%进化阶段%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

generation=1;

Evolution\_popualtion = Initial\_population;

Generations\_of\_best\_individual=zeros(Initial\_population\_individual\_num,Code\_Num);

Population\_cross\_new=zeros(Initial\_population\_individual\_num,Code\_Num);

Population\_mutate\_new=zeros(Initial\_population\_individual\_num,Code\_Num);

while generation\<Max\_generation+1

for j=1:2:Initial\_population\_individual\_num

\%选择

selected\_num=select(P\_popualtion\_distri);

\%交叉

Population\_cross=crossover(Evolution\_popualtion,selected\_num,P\_crossover,City\_Num,Link\_Num);

Population\_cross\_new(j,:)=Population\_cross(1,:);

Population\_cross\_new(j+1,:)=Population\_cross(2,:);

\%变异

Population\_mutate\_new(j,:)=mutate(Population\_cross\_new(j,:),P\_mutate,City\_Num,Link\_Num);
Population\_mutate\_new(j+1,:)=mutate(Population\_cross\_new(j+1,:),P\_mutate,City\_Num,Link\_Num);

end

Evolution\_popualtion=Population\_mutate\_new; %产生了新的种群

\%%%%%%%%%%%%%%%%%%%%%%%%计算新种群中个体的适应度%%%%%%%%%%%%%%%%%%%%%
\[Individual\_fitness,P\_popualtion\_distri\]=population\_fitness(Evolution\_popualtion,City\_coordinate,City\_Dist,City\_Population,Link\_Num);

\%记录当代最佳个体的适应度和个体在群落中的位置
\[Best\_fitness\_individual\_value,Best\_fitness\_individual\_num\]=max(Individual\_fitness);

\%记录当前代的最佳个体

Best\_individual=Evolution\_popualtion(Best\_fitness\_individual\_num,:);

\%记录每代最佳个体

Generations\_of\_best\_individual(generation,:)=Best\_individual;

\[\~,\~,XFp,si2,sid2\] = Decode(Best\_individual,12,Link\_Num);

XId = \[si2;sid2\]\';

\%记录每代最佳个体的适应度，即总网络价值

Generations\_of\_best\_individual\_fitness(generation)=Single\_Individual\_fitness(XId,XFp,City\_Dist,City\_coordinate,City\_Population);

generation=generation+1;

generation

end

function\[Individual\_fitness,City\_connection,Xload2\]=Single\_Individual\_fitness(XId,XFp,City\_coordinate,City\_Locaiton,City\_Population)

City\_num = size(City\_Locaiton,1);

\%计算连接矩阵

City\_connection = 1-tril(ones(City\_num,City\_num),0);

City\_connection = City\_connection(:);

Ind = find(City\_connection==1);

City\_connection(Ind)=1:length(Ind);

Xc = zeros(1,City\_num\*City\_num);

for ii=1:length(XId)

Xc(City\_connection==XId(ii,1)) = 1;

City\_connection(City\_connection==XId(ii,1))=XId(ii,2);

end

City\_connection(Xc==0)=0;

City\_connection = reshape(City\_connection,City\_num,City\_num);

City\_connection = City\_connection+City\_connection\';

\%判断是否连接了所有结点的问题

Xd = City\_connection\>0;

result=TSP(1,Xd);

if (length(result)\<City\_num)

Individual\_fitness =0;

return;

end

XInt = City\_connection\>0;

City\_coordinate= City\_coordinate.\*XInt;

City\_coordinate(XInt==0) = Inf;

\%路径速率计算

Xload = ones(City\_num,City\_num);

SnrReq = \[Inf 3000 1200 600\];

Capacity\_Table = \[0 8 16 32\];

for ii =1:City\_num

for jj=1:City\_num

if (City\_connection(ii,jj)\>=1)

Dist= norm(City\_Locaiton(ii,:)-City\_Locaiton(jj,:));

Ind = find(SnrReq\>Dist);

ModRate = Capacity\_Table(Ind(end));

Xload(ii,jj) = City\_connection(ii,jj)\*ModRate;

end

end

end

\%计算含一个中间结点情况下的速率分配

Xload2 = zeros(City\_num,City\_num);

XFp = XFp\*sum(Xload(:))/4;

for ii =1:City\_num

for jj=ii+1:City\_num

\[shortestPath, totalCost\] = Dijkstra(City\_coordinate, ii, jj);

if (totalCost==Inf \|\| length(shortestPath)\~=3)

Xload2(ii,jj) = 0;

Xload2(jj,ii) = 0;

else

Xload2(jj,ii) = XFp(ii,jj);

Xload2(jj,ii) = XFp(ii,jj);

Xload(ii,shortestPath(2))=Xload(ii,shortestPath(2))-XFp(ii,jj);

Xload(shortestPath(2),ii)=Xload(shortestPath(2),ii)-XFp(ii,jj);

Xload(shortestPath(2),jj)=Xload(shortestPath(2),jj)-XFp(ii,jj);

Xload(jj,shortestPath(2))=Xload(jj,shortestPath(2))-XFp(ii,jj);

end

end

end

if (min(Xload(:))\<0)

Individual\_fitness= 0;

return;

else

for ii =1:City\_num

for jj=ii+1:City\_num

Xload2(ii,jj)= Xload(ii,jj);

Xload2(jj,ii)= Xload(jj,ii);

end

end

end

\% 计算总的价值

Individual\_fitness = 0;

for ii =1:City\_num

for jj=ii+1:City\_num

if (City\_connection(ii,jj)\>=1)

Dist= norm(City\_Locaiton(ii,:)-City\_Locaiton(jj,:));

Ind = find(SnrReq\>Dist);

ModRate = Capacity\_Table(Ind(end));

Individual\_fitness = Individual\_fitness+
sqrt(City\_Population(ii)\*City\_Population(jj))\*Xload2(ii,jj);

end

end

end

end

\%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%表达该网络%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\%计算总价值，城市连接，城市容量

\[\~,\~,XFp,si2,sid2\] =
Decode(Generations\_of\_best\_individual(end,:),12,Link\_Num);

XId = \[si2;sid2\]\';

\[Individual\_fitness,City\_connection\]=Single\_Individual\_fitness(XId,XFp,City\_Dist,City\_coordinate,City\_Population);

\%%%%%%%%%%%%%%%%%%%%%%%%%%%%%作图%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

figure(1);

clf;hold on;

plot(City\_Locaiton(:,2),City\_Locaiton(:,1),\'ko\');

\%显示城市名字

for i= 1:City\_Num

text(City\_Locaiton(i,2),City\_Locaiton(i,1),City\_Name{i},\'fontsize\',18)

end

\%画城市间连线

for ii=1:City\_Num

for jj=1:City\_Num

if (City\_connection(ii,jj)\>=1)

plot(\[City\_Locaiton(ii,2) City\_Locaiton(jj,2)\],\...

\[City\_Locaiton(ii,1)
City\_Locaiton(jj,1)\],\'r\--\',\'linewidth\',double(City\_connection(ii,jj)));

end

end

end

title(\[\'容量为\' num2str(Individual\_fitness) \'mTb/s\'\])

ylabel(\'纬度\',\'fontsize\',15);

xlabel(\'经度\',\'fontsize\',15);

figure(2);

plot(Generations\_of\_best\_individual\_fitness);

title(\[\'连接数为\' num2str(Link\_Num)\]);

ylabel(\'网络价值\',\'fontsize\',15);

xlabel(\'迭代次数\',\'fontsize\',15);

**问题2-3主要代码**

clear ;clc;close all;

\%目标连接数

\% Link\_Num = 16;

Link\_Num = 33;

\%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%城市信息%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

City\_Num = 12;

Link\_Num\_Total=(City\_Num-1)\*City\_Num/2;

City\_Name = \[\"哈尔滨\",\"北京&天津\", \"郑州\", \"上海\", \"武汉\",
\"广州&深圳\", \"西安\", \"乌鲁木齐\", \"拉萨\", \"成都\", \"昆明\",
\"重庆\"\];

City\_Population = \[9.9526 34.8245 9.03 23.8043 10.12 23.3853 8.83 3.8
0.9025 16.0477 7.2131 8.56\];

City\_Locaiton=\[45.8 126.53;39.92 116.46;34.75 113.66;31.23 121.47;30.6
114.3;23.13 113.27;34.27 108.93;43.82 87.62;29.97 91.11;30.67
104.07;25.05 102.72;29.57 106.55\];

\%City\_coordinate为经纬度转换后的坐标

City\_coordinate=city\_information(City\_Locaiton);

City\_Dist = zeros(City\_Num,City\_Num);

for ii=1:City\_Num

for jj=1:City\_Num

City\_Dist(ii,jj) = norm(City\_Locaiton(ii,:)-City\_Locaiton(jj,:));

end

end

\%%%%%%%%%%%%%%%%%%%%%%%%%%%%%遗传算法参数%%%%%%%%%%%%%%%%%%%%%%%%%%%

Initial\_population\_individual\_num=300; %初始种群大小

Max\_generation=300; %最大代数

P\_crossover=0.3; %交叉概率

P\_mutate=0.01; %变异概率

\%%%%%%%%%%%%%%%%%%%%%%%%%%%%产生初始种群%%%%%%%%%%%%%%%%%%%%%%%%%%%%

max\_Link\_num = 2;

Code\_Num = Link\_Num\_Total+Link\_Num\_Total+City\_Num\*City\_Num;

Initial\_population=zeros(Initial\_population\_individual\_num,Code\_Num);

for i=1:Initial\_population\_individual\_num

si=randperm(Link\_Num\_Total);

sid=randi(\[1 max\_Link\_num\],1,Link\_Num\_Total);

xx = rand(City\_Num,City\_Num);

xx = xx/sum(xx(:));

Initial\_population(i,:) = Code(si,sid,xx);

end

\%%%%%%%%%%%%%%%%%%%%%%%%%%%计算种群的适应度%%%%%%%%%%%%%%%%%%%%%%%%%

\[\~,P\_popualtion\_distri\]=population\_fitness(Initial\_population,City\_coordinate,City\_Dist,City\_Population,Link\_Num);

\%%%%%%%%%%%%%%%%%%%%%%%%%进化阶段%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

generation=1;

Evolution\_popualtion = Initial\_population;

Generations\_of\_best\_individual=zeros(Initial\_population\_individual\_num,Code\_Num);

Population\_cross\_new=zeros(Initial\_population\_individual\_num,Code\_Num);

Population\_mutate\_new=zeros(Initial\_population\_individual\_num,Code\_Num);

while generation\<Max\_generation+1

for j=1:2:Initial\_population\_individual\_num

\%选择

selected\_num=select(P\_popualtion\_distri);

\%交叉

Population\_cross=crossover(Evolution\_popualtion,selected\_num,P\_crossover,City\_Num,Link\_Num);

Population\_cross\_new(j,:)=Population\_cross(1,:);

Population\_cross\_new(j+1,:)=Population\_cross(2,:);

\%变异

Population\_mutate\_new(j,:)=mutate(Population\_cross\_new(j,:),P\_mutate,City\_Num,Link\_Num);

Population\_mutate\_new(j+1,:)=mutate(Population\_cross\_new(j+1,:),P\_mutate,City\_Num,Link\_Num);

end

Evolution\_popualtion=Population\_mutate\_new; %产生了新的种群

\%%%%%%%%%%%%%%%%%%%%%%%%计算新种群中个体的适应度%%%%%%%%%%%%%%%%%%%%%
\[Individual\_fitness,P\_popualtion\_distri\]=population\_fitness(Evolution\_popualtion,City\_coordinate,City\_Dist,City\_Population,Link\_Num);

\%记录当代最佳个体的适应度和个体在群落中的位置
\[Best\_fitness\_individual\_value,Best\_fitness\_individual\_num\]=max(Individual\_fitness);

\%记录当前代的最佳个体Best\_individual=Evolution\_popualtion(Best\_fitness\_individual\_num,:);

\%记录每代最佳个体

Generations\_of\_best\_individual(generation,:)=Best\_individual;

\[\~,\~,XFp,si2,sid2\] = Decode(Best\_individual,12,Link\_Num);

XId = \[si2;sid2\]\';

\%记录每代最佳个体的适应度，即总网络价值

Generations\_of\_best\_individual\_fitness(generation)=Single\_Individual\_fitness(XId,XFp,City\_Dist,City\_coordinate,City\_Population);

generation=generation+1;

generation

end

\%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%表达该网络%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\%计算总价值，城市连接，城市容量

\[\~,\~,XFp,si2,sid2\] =
Decode(Generations\_of\_best\_individual(end,:),12,Link\_Num);

XId = \[si2;sid2\]\';

\[Individual\_fitness,City\_connection\]=Single\_Individual\_fitness(XId,XFp,City\_Dist,City\_coordinate,City\_Population);

\%%%%%%%%%%%%%%%%%%%%%%%%%%%%%作图%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

figure(1);

clf;hold on;

plot(City\_Locaiton(:,2),City\_Locaiton(:,1),\'ko\');

\%显示城市名字

for i= 1:City\_Num

text(City\_Locaiton(i,2),City\_Locaiton(i,1),City\_Name{i},\'fontsize\',18)

end

\%画城市间连线

for ii=1:City\_Num

for jj=1:City\_Num

if (City\_connection(ii,jj)\>=1)

plot(\[City\_Locaiton(ii,2) City\_Locaiton(jj,2)\],\...

\[City\_Locaiton(ii,1)
City\_Locaiton(jj,1)\],\'r\--\',\'linewidth\',double(City\_connection(ii,jj)));

end

end

end

title(\[\'容量为\' num2str(Individual\_fitness) \'mTb/s\'\])

ylabel(\'纬度\',\'fontsize\',15);

xlabel(\'经度\',\'fontsize\',15);

figure(2);

plot(Generations\_of\_best\_individual\_fitness);

title(\[\'连接数为\' num2str(Link\_Num)\]);

ylabel(\'网络价值\',\'fontsize\',15);

xlabel(\'迭代次数\',\'fontsize\',15);

\%计算所有种群的适应度

function
\[Individual\_fitness,P\_popualtion\_distri\]=population\_fitness(Evolution\_popualtion,City\_coordinate,City\_Dist,City\_Population,Link\_Num)

City\_num = size(City\_coordinate,1);

Individual\_num=size(Evolution\_popualtion,1); %读取种群大小

Individual\_fitness=zeros(Individual\_num,1);

for i=1:Individual\_num

\[\~,\~,XFp,si2,sid2\] =
Decode(Evolution\_popualtion(i,:),City\_num,Link\_Num);

XId = \[si2;sid2\]\';

Individual\_fitness(i)=Single\_Individual\_fitness(XId,XFp,City\_Dist,City\_coordinate,City\_Population);
%计算函数值，即适应度

end

Individual\_fitness=Individual\_fitness\';

\%根据个体的适应度计算其被选择的概率

All\_individual\_fitness\_sum=0;

for i=1:Individual\_num

All\_individual\_fitness\_sum=All\_individual\_fitness\_sum+Individual\_fitness(i)\^15;%
让适应度越好的个体被选择概率越高

end

P\_individual\_for\_live=zeros(Individual\_num,1);

for i=1:Individual\_num

P\_individual\_for\_live(i)=Individual\_fitness(i)\^15/All\_individual\_fitness\_sum;

end

\%计算累积概率

P\_popualtion\_distri=zeros(Individual\_num,1);

P\_popualtion\_distri(1)=P\_individual\_for\_live(1);

for i=2:Individual\_num

P\_popualtion\_distri(i)=P\_popualtion\_distri(i-1)+P\_individual\_for\_live(i);

end

P\_popualtion\_distri=P\_popualtion\_distri\';

End

**问题3代码**

clear all;clc;

close all;

New\_constellation=Genetic\_algorithm();

\%假设传输10000个符号

N\_symbol=10000;

for snrdb=1:1:25

\%%%%%%%%%%%%%%%%%%%%%%%8qam原始信号%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

dot\_8qam = \[1+1j -1+1j -1-1j 1-1j 1i\*3 -1i\*(1+3\^(1/2)) (1+3\^(1/2))
-(1+3\^(1/2))\]; %8qam星座映射点

\%产生符号序列% 映射16qam

rand0\_7 = randi(8,1,N\_symbol);

s\_8qam\_old = zeros(1,N\_symbol);

for a=1:N\_symbol

s\_8qam\_old(1,a)=dot\_8qam(1,rand0\_7(1,a));

end

\%8qam原始二进制位流

s\_8qam\_oct\_old=qamdemod\_8qam(s\_8qam\_old,8);
%此时解调出来的是8进制信号

s\_8qam\_bit\_stream\_old=de2bi(s\_8qam\_oct\_old,3,\'left-msb\');
%转化为对应的二进制比特流

s\_8qam\_bit\_stream\_old=reshape(s\_8qam\_bit\_stream\_old.\',numel(s\_8qam\_bit\_stream\_old),1\');

\%%%%%%%%%%%%%%%%%%%%%%%%%8qam原始信号%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

s\_8qam\_oct\_new = randi(8,1,N\_symbol)-1;

\%8qam\_new原始二进制位流

s\_8qam\_new =
qammod\_new\_constellation(s\_8qam\_oct\_new,New\_constellation);%%%%%%%%%%%用新的星座图，发送符号

s\_8qam\_bit\_stream\_new=de2bi(s\_8qam\_oct\_new,3,\'left-msb\');
%转化为对应的二进制比特流

s\_8qam\_bit\_stream\_new=reshape(s\_8qam\_bit\_stream\_new.\',numel(s\_8qam\_bit\_stream\_new),1\');

\%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\%8qam加高斯白噪声

w\_8qam\_old = awgn(s\_8qam\_old,snrdb,\'measured\');

r\_8qam\_old = w\_8qam\_old;

\%8qam加高斯白噪声

w\_8qam\_new = awgn(s\_8qam\_new,snrdb,\'measured\');

r\_8qam\_new = w\_8qam\_new;

\%8qam BER

r\_8qam\_oct\_old=qamdemod\_8qam(r\_8qam\_old,8);
%此时解调出来的是8进制信号

r\_8qam\_bit\_stream\_old=de2bi(r\_8qam\_oct\_old,3,\'left-msb\');
%转化为对应的二进制比特流

r\_8qam\_bit\_stream\_old=reshape(r\_8qam\_bit\_stream\_old.\',numel(r\_8qam\_bit\_stream\_old),1\');

ber\_8qam\_old(snrdb)=biterr(s\_8qam\_bit\_stream\_old,r\_8qam\_bit\_stream\_old)/(N\_symbol\*3);

\%8qam BER

r\_8qam\_oct\_new=qamdemod\_new\_constellation(r\_8qam\_new,New\_constellation);
%此时解调出来的是8进制信号

r\_8qam\_bit\_stream\_new=de2bi(r\_8qam\_oct\_new,3,\'left-msb\');
%转化为对应的二进制比特流

r\_8qam\_bit\_stream\_new=reshape(r\_8qam\_bit\_stream\_new.\',numel(r\_8qam\_bit\_stream\_new),1\');

ber\_8qam\_new(snrdb)=biterr(s\_8qam\_bit\_stream\_new,r\_8qam\_bit\_stream\_new)/(N\_symbol\*3);

end

\%8qam\_old星座图

hold on;

figure(4);clf;hold on;

subplot(1,2,1);plot(s\_8qam\_old,\'b.\');title(\'8QAM发射星座图\');axis
equal;axis(\[-5 5 -5 5\])

subplot(1,2,2);plot(r\_8qam\_old,\'b.\');title(\'8QAM接收星座图(25db)\');axis
equal;axis(\[-5 5 -5 5\])

\%8qam\_new星座图

hold on;

figure(2);clf;hold on;

subplot(1,2,1);plot(s\_8qam\_new,\'b.\');title(\'8QAM发射星座图\');axis
equal;axis(\[-5 5 -5 5\])

subplot(1,2,2);plot(r\_8qam\_new,\'b.\');title(\'8QAM接收星座图(25db)\');axis
equal;axis(\[-5 5 -5 5\])

\%%%%%%%%%%%%%%%%%%%%%%%%%%%%8qam BERvsSNR%%%%%%%%%%%%%%%%%%%%%%%

figure(5);

snrdb=1:1:25;

semilogy(snrdb,ber\_8qam\_old,\'-bo\',snrdb,ber\_8qam\_new,\'-mh\')

title(\'8QAM OLD 16QAM NEW with awgn\');

xlabel(\'Signal to noise ratio\');

ylabel(\'Bit error rate\');

legend(\'8QAM OLD\',\'8QAM NEW\');

axis(\[-2 25 -5 2\]);

grid on;

function New\_constellation = Genetic\_algorithm()

\%种群大小

population\_individual\_num = 50;

\%二进制编码长度

code\_length=8;

\%交叉概率

p\_crossover = 0.1;

\%变异概率

p\_mutae = 0.02;

\%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\%初始种群

Initial\_population =
Init\_population(population\_individual\_num,code\_length);

\%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\%存储最佳星座点

save\_fit\_value =0;

New\_constellation = \[\];

Evolution\_popualtion = Initial\_population;

for generation = 1:200000

\%计算适应度值（函数值）

evaluate\_value = cal\_evaluate\_value(Evolution\_popualtion);

fit\_value = evaluate\_value;

\%选择

new\_population = select(Evolution\_popualtion,fit\_value);

\%交叉

new\_population = crossover(new\_population,p\_crossover);

\%变异

new\_population = mutate(new\_population,p\_mutae);

\%更新

Evolution\_popualtion = update\_popualtion(new\_population);

\%寻找最优解

\%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\%计算个体适应度

\[bestindividual,best\_fit\_value\] =
Find\_Best\_Individual(Evolution\_popualtion,fit\_value);

if (save\_fit\_value\<best\_fit\_value)

save\_fit\_value = best\_fit\_value;

New\_constellation = bestindividual.\*3;

end

Fitness(generation) = (best\_fit\_value);

if mod(generation,100) == 0

figure(1);clf

plot(New\_constellation,\'x\');

axis(\[-5 5 -5 5\]);

title(\[\'迭代次数为n=\' num2str(generation)\]);

pause(0.01);

end

end

figure(2);clf

plot(New\_constellation,\'x\');

figure(3);

plot(Fitness)

end

function Initial\_population=Init\_population(popsize,chromlength)

Initial\_population =
(rand(popsize,chromlength)\*2-1)+(rand(popsize,chromlength)\*2-1)\*1i;

end

function \[population\] = update\_popualtion(population)

population\_real=real(population);

population\_imag=imag(population);

population\_real = max(min(population\_real,1),-1);

population\_imag = max(min(population\_imag,1),-1);

population = population\_real+population\_imag\*1i;

end

function \[evaluate\_value\] = cal\_evaluate\_value(population)

\[individual,len\] = size(population);

for kk=1:individual

Dis = inf(len,len);

for ii=1:len

for jj=ii+1:len

Dis(ii,jj) = abs(population(kk,ii)-population(kk,jj));

end

end

minDis = min(Dis(:));

if (minDis\~=0)

population(kk,:) = population(kk,:)/minDis;

evaluate\_value(kk) = 1/(mean(abs(population(kk,:)).\^2));

else

evaluate\_value (kk)= 0;

end

end

end

function \[new\_population\] = select(population,individual\_fitness)

\[px,\~\] = size(population);

total\_fitness = sum(individual\_fitness);

p\_fitness = individual\_fitness/total\_fitness;

p\_fitness = cumsum(p\_fitness);%概率求和排序

ms = sort(rand(px,1));%从小到大排列

fitin = 1;

newin = 1;

while newin\<=px

if(ms(newin))\<p\_fitness(fitin)

new\_population(newin,:)=population(fitin,:);

newin = newin+1;

else

fitin=fitin+1;

end

end

end

function \[new\_population\] = crossover(population,pc)

\[population\_x,population\_y\] = size(population);

new\_population = ones(size(population));

for i = 1:2:population\_x-1

if(rand\<pc)

cross\_num = round(rand\*population\_y);

new\_population(i,:) =
\[population(i,1:cross\_num),population(i+1,cross\_num+1:population\_y)\];

new\_population(i+1,:) =
\[population(i+1,1:cross\_num),population(i,cross\_num+1:population\_y)\];

else

new\_population(i,:) = population(i,:);

new\_population(i+1,:) = population(i+1,:);

end

end

end

function \[new\_populatin\] = mutate(population,p\_mutate)

\[population\_x,population\_y\] = size(population);

new\_populatin = ones(size(population));

for i = 1:population\_x

mutate\_num = ceil(rand\*population\_y);

if(rand\<p\_mutate && \~isempty(mutate\_num))

new\_populatin(i,:) = population(i,:);

new\_populatin(i,mutate\_num) = new\_populatin(i,mutate\_num)+\...

(randn(1,length(mutate\_num))+randn(1,length(mutate\_num))\*1i)\*0.05;

else

new\_populatin(i,:) = population(i,:);

end

end

end

function \[best\_individual, best\_fit\_value\] =
Find\_Best\_Individual(popualtion,individual\_fitness\_value)

\[population\_x,\~\] = size(popualtion);

best\_individual = popualtion(1,:);

best\_fit\_value = individual\_fitness\_value(1);

for i = 2:population\_x

if individual\_fitness\_value(i)\>best\_fit\_value

best\_individual = popualtion(i,:);

best\_fit\_value = individual\_fitness\_value(i);

end

end

end

function \[out\] = qamdemod\_8qam(In,mod)

switch mod

case 8

Symmbol\_8qam = \[1+1j -1+1j -1-1j 1-1j 1i\*3 -1i\*(1+3\^(1/2))
(1+3\^(1/2)) -(1+3\^(1/2))\];

for a=1:length(In)

distance = abs(Symmbol\_8qam-In(a));

\[\~,Ind\] = min(distance);

out(a) = Ind-1;

end

end

end

function Out = qammod\_new\_constellation(xIn,ModSymmbol)

Out = ModSymmbol(xIn+1);

end

function Out = qamdemod\_new\_constellation(In,ModSymmbol)

for i=1:length(In)

Dis = abs(ModSymmbol-In(i));

\[\~,Ind\] = min(Dis);

Out(i) = Ind-1;

end

end
